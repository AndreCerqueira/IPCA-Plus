Index: app/src/main/java/com/singularity/ipcaplus/chat/ChatActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.singularity.ipcaplus.chat\r\n\r\nimport android.annotation.SuppressLint\r\nimport android.app.ActionBar\r\nimport android.content.ContentValues.TAG\r\nimport android.content.Intent\r\nimport android.os.Build\r\nimport android.os.Bundle\r\nimport android.util.Log\r\nimport android.view.*\r\nimport android.widget.ImageView\r\nimport android.widget.TextView\r\nimport androidx.annotation.RequiresApi\r\nimport androidx.appcompat.app.AppCompatActivity\r\nimport androidx.core.view.isVisible\r\nimport androidx.recyclerview.widget.DefaultItemAnimator\r\nimport androidx.recyclerview.widget.LinearLayoutManager\r\nimport androidx.recyclerview.widget.RecyclerView\r\nimport com.google.firebase.Timestamp\r\nimport com.google.firebase.auth.ktx.auth\r\nimport com.google.firebase.firestore.Query\r\nimport com.google.firebase.firestore.ktx.firestore\r\nimport com.google.firebase.ktx.Firebase\r\nimport com.singularity.ipcaplus.drawer.CalendarActivity\r\nimport com.singularity.ipcaplus.R\r\nimport com.singularity.ipcaplus.utils.Utilis\r\nimport com.singularity.ipcaplus.cryptography.decryptWithAESmeta\r\nimport com.singularity.ipcaplus.cryptography.encryptMeta\r\nimport com.singularity.ipcaplus.cryptography.getMetaOx\r\nimport com.singularity.ipcaplus.databinding.ActivityChatBinding\r\nimport com.singularity.ipcaplus.models.Chat\r\nimport com.singularity.ipcaplus.models.Message\r\nimport com.singularity.ipcaplus.utils.Backend\r\nimport com.singularity.ipcaplus.utils.Backend.createJsonArrayString\r\nimport kotlinx.coroutines.*\r\nimport org.json.JSONArray\r\nimport org.json.JSONObject\r\nimport java.io.BufferedOutputStream\r\nimport java.io.BufferedWriter\r\nimport java.io.OutputStream\r\nimport java.io.OutputStreamWriter\r\nimport java.net.URL\r\nimport java.time.LocalDateTime\r\nimport java.time.format.DateTimeFormatter\r\nimport javax.net.ssl.HttpsURLConnection\r\n\r\nclass ChatActivity : AppCompatActivity() {\r\n\r\n    var messages = arrayListOf<Message>()\r\n    var currentUserIsAdmin = false\r\n    private lateinit var binding: ActivityChatBinding\r\n    private lateinit var chat_id : String\r\n    var tokens_adress = arrayListOf<String>()\r\n    var chat_user_uids = arrayListOf<String>()\r\n    private var mAdapter: RecyclerView.Adapter<*>? = null\r\n    private var mLayoutManager: LinearLayoutManager? = null\r\n\r\n    val db = Firebase.firestore\r\n    @SuppressLint(\"WrongConstant\")\r\n    @RequiresApi(Build.VERSION_CODES.O)\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_chat)\r\n\r\n        binding = ActivityChatBinding.inflate(layoutInflater)\r\n        setContentView(binding.root)\r\n\r\n        supportActionBar?.displayOptions = ActionBar.DISPLAY_SHOW_CUSTOM\r\n        supportActionBar?.setCustomView(R.layout.appbar_custom_layout_chat)\r\n        findViewById<TextView>(R.id.AppBarTittle).text = \"Chat name\"\r\n        // Back button\r\n        findViewById<ImageView>(R.id.BackButtonImageView).setOnClickListener{\r\n            finish()\r\n        }\r\n\r\n        // Variables\r\n        chat_id = intent.getStringExtra(\"chat_id\").toString()\r\n        val current = LocalDateTime.now()\r\n\r\n        val formatter = DateTimeFormatter.BASIC_ISO_DATE\r\n        val formatted = current.format(formatter)\r\n\r\n        // Check if user is admin\r\n        Backend.getChatAdminIds(chat_id) {\r\n            val currentUser = Firebase.auth.currentUser!!.uid\r\n            for (admin in it) {\r\n                if (admin == currentUser)\r\n                    currentUserIsAdmin = true\r\n            }\r\n        }\r\n\r\n        // Get all members id of chat\r\n        Backend.getChatUsersUids(chat_id){\r\n            chat_user_uids.clear()\r\n            chat_user_uids.addAll(it)\r\n\r\n            for (userId in chat_user_uids){\r\n                // Getting all of tokens of  profile associated devices\r\n                Backend.getAllTokens(userId) {\r\n                    if (tokens_adress.isEmpty()){\r\n                        tokens_adress.clear()\r\n                    }\r\n                    tokens_adress.addAll(it)\r\n\r\n                    /*GlobalScope.launch {\r\n                        withContext(Dispatchers.IO){\r\n                            createNotificationGroup(\"grupotrablahotentativa\", createJsonArrayString(tokens_adress))\r\n                        }\r\n                    }*/\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n        val profilePicfromTop = findViewById<ImageView>(R.id.ProfileImageView)\r\n        Utilis.getFile(this, \"chats/$chat_id/icon.png\", \"png\") { bitmap ->\r\n            profilePicfromTop.setImageBitmap(bitmap)\r\n        }\r\n\r\n        println(\"Current Date is: $formatted\")\r\n\r\n        // Send Message\r\n        binding.fabSend.setOnClickListener {\r\n            if(!binding.editTextMessage.text.isNullOrBlank()) {\r\n                // get data of ecripted shared preferences (\"chatuid\" -> \"key\")\r\n                val keygen = getMetaOx(this, chat_id)\r\n                // Build encryptation data of message send by the user\r\n                var meta = encryptMeta( binding.editTextMessage.text.toString(), keygen.toString())\r\n                val savedText = binding.editTextMessage.text.toString()\r\n\r\n                val message = Message(\r\n                    Firebase.auth.currentUser!!.uid,\r\n                    meta.toString(),\r\n                    Timestamp.now(),\r\n                    \"\"\r\n\r\n                )\r\n                db.collection(\"chat\").document(\"$chat_id\").collection(\"message\")\r\n                    .add(message.toHash())\r\n                    .addOnSuccessListener { documentReference ->\r\n\r\n                        GlobalScope.launch {\r\n                            withContext(Dispatchers.IO){\r\n                                //APA91bEKDInIYA242YofpahBmhB57pEI4gNT63DJJenWCccJGqeSYrWzj0BSruX49DhVp2vGSY5xJ2fEJk2vhtoraT3_bbjEKw4Nx3eJKj7tttVRPjQs0Uc_OPkrcj4twR70H5tAilnY\r\n                                println(\"AVEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\"+ savedText)\r\n                                sendNotificationToGroup( chat_id, savedText, \"APA91bGaOoMTjTD2s9MU63F1AvLqP6tkwdAFE0Mqs9jbghlSgcWlfe_38CboFiE2iiWFoKqNRwhF0G_TA5X9xegTL0_Tg0OGuFadJuBj1sGZqjqCcmF1EH2ZeRU7ySHosdNkmLmmOyFF\")\r\n                            }\r\n                        }\r\n                        Log.d(TAG, \"DocumentSnapshot added with ID: ${documentReference.id}\")\r\n\r\n\r\n                    }\r\n                    .addOnFailureListener { e ->\r\n                        Log.w(TAG, \"Error adding document\", e)\r\n                    }\r\n                binding.editTextMessage.text.clear()\r\n\r\n            }\r\n        }\r\n\r\n        // Show Messages\r\n        db.collection(\"chat\").document(\"$chat_id\").collection(\"message\").orderBy(\"time\", Query.Direction.DESCENDING)\r\n            .addSnapshotListener { documents, e ->\r\n\r\n                documents?.let {\r\n                    messages.clear()\r\n                    for (document in it) {\r\n                        Log.d(TAG, \"${document.id} => ${document.data}\")\r\n                        val message = Message.fromHash(document)\r\n                        messages.add(message)\r\n\r\n                    }\r\n                    mAdapter?.notifyDataSetChanged()\r\n                }\r\n\r\n            }\r\n\r\n        // Recycler View Messages\r\n        mLayoutManager = LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)\r\n        binding.recycleViewChat.layoutManager = mLayoutManager\r\n        mAdapter = MessageAdapter()\r\n        binding.recycleViewChat.itemAnimator = DefaultItemAnimator()\r\n        binding.recycleViewChat.adapter = mAdapter\r\n\r\n        mLayoutManager!!.reverseLayout = true\r\n\r\n    }\r\n\r\n    /*\r\n       This function create the action bar above the activity\r\n    */\r\n    override fun onCreateOptionsMenu(menu: Menu): Boolean {\r\n        val inflater: MenuInflater = menuInflater\r\n        inflater.inflate(R.menu.menu_chat, menu)\r\n\r\n        db.collection(\"chat\")\r\n            .addSnapshotListener { documents, e ->\r\n                documents?.let {\r\n                    for (document in it) {\r\n                        if(document.id == chat_id) {\r\n                            val chat = Chat.fromHash(document)\r\n                            val name = Utilis.getFirstAndLastName(chat.name)\r\n                            //supportActionBar?.title = chat.name\r\n                            findViewById<TextView>(R.id.AppBarTittle).text = name\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n        return true\r\n    }\r\n\r\n\r\n    /*\r\n        This function define the events of the action bar buttons\r\n     */\r\n    override fun onOptionsItemSelected(item: MenuItem): Boolean {\r\n        super.onOptionsItemSelected(item)\r\n\r\n        when (item.itemId){\r\n            R.id.calendario -> {\r\n                val intent = Intent(this, CalendarActivity::class.java)\r\n                intent.putExtra(\"chat_id\", chat_id)\r\n                intent.putExtra(\"is_admin\", currentUserIsAdmin)\r\n                startActivity(intent)\r\n                return true\r\n            }\r\n            R.id.chatMore -> {\r\n                val intent = Intent(this, ChatMoreActivity::class.java)\r\n                intent.putExtra(\"chat_id\", chat_id)\r\n                println(\"3------------------------------ \" + currentUserIsAdmin)\r\n                intent.putExtra(\"is_admin\", currentUserIsAdmin)\r\n                intent.putExtra(\"chat_name\",  Utilis.getFirstAndLastName(findViewById<TextView>(R.id.AppBarTittle).text.toString()))\r\n                startActivity(intent)\r\n                return true\r\n            }\r\n        }\r\n\r\n        return false\r\n    }\r\n\r\n\r\n    // When the support action bar back button is pressed, the app will go back to the previous activity\r\n    override fun onSupportNavigateUp(): Boolean {\r\n        onBackPressed()\r\n        return true\r\n    }\r\n\r\n\r\n    inner class MessageAdapter : RecyclerView.Adapter<MessageAdapter.ViewHolder>() {\r\n\r\n        inner class ViewHolder(val v: View) : RecyclerView.ViewHolder(v)\r\n\r\n        var otherUser = false\r\n\r\n        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {\r\n            if(viewType == 1) {\r\n                otherUser = false\r\n                return ViewHolder(\r\n                    LayoutInflater.from(parent.context).inflate(R.layout.row_message_self, parent, false))\r\n            } else if (viewType == 2){\r\n                otherUser = false\r\n                return ViewHolder(\r\n                    LayoutInflater.from(parent.context).inflate(R.layout.row_message_system, parent, false))\r\n            } else {\r\n                otherUser = true\r\n                return ViewHolder(\r\n                    LayoutInflater.from(parent.context).inflate(R.layout.row_message_others, parent, false))\r\n            }\r\n\r\n        }\r\n\r\n        @RequiresApi(Build.VERSION_CODES.M)\r\n         override fun onBindViewHolder(holder: ViewHolder, position: Int) {\r\n\r\n\r\n            holder.v.apply {\r\n\r\n                val textViewMessage = findViewById<TextView>(R.id.textViewMessage)\r\n                val timeLastMessage = findViewById<TextView?>(R.id.timeLastMessage)\r\n                val textViewUsername = findViewById<TextView?>(R.id.textViewUsername)\r\n\r\n\r\n                timeLastMessage?.isVisible = false\r\n                val keygen = getMetaOx(context, chat_id)\r\n                val message_decripted = decryptWithAESmeta(keygen.toString(), messages[position].message)\r\n\r\n               /* if (otherUser) {\r\n                        Backend.getUserProfile(messages[position].user) {\r\n                            val userName = Utilis.getFirstAndLastName(it.name)\r\n                            textViewUsername.text = userName\r\n                        }\r\n                    }\r\n                */\r\n\r\n                textViewMessage.text = message_decripted\r\n                println(message_decripted)\r\n                if(position == messages.size - 1) {\r\n                    val data = Utilis.getDate(\r\n                        messages[position].time.seconds * 1000,\r\n                        \"yyyy-MM-dd'T'HH:mm:ss.SSS\"\r\n                    )\r\n                    timeLastMessage.isVisible = true\r\n                    timeLastMessage.text = Utilis.getHours(data) + \":\" + Utilis.getMinutes(data)\r\n                }\r\n\r\n                if (otherUser) {\r\n                    val imageViewUser = findViewById<ImageView?>(R.id.imageViewUser)\r\n                    if (imageViewUser != null) {\r\n                        Utilis.getFile(context, \"profilePictures/${messages[position].user}.png\", \"png\") { bitmap ->\r\n                            imageViewUser.setImageBitmap(bitmap)\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        override fun getItemViewType(position: Int) : Int {\r\n            if (messages[position].user == Firebase.auth.currentUser!!.uid) {\r\n                return 1\r\n            } else if (messages[position].user == \"system\"){\r\n                return 2\r\n            } else {\r\n                return 0\r\n            }\r\n        }\r\n\r\n        override fun getItemCount(): Int {\r\n            return messages.size\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n    private suspend fun  createNotificationGroup(notificationKeyName : String, registrationIds : JSONArray)  {\r\n\r\n        try {\r\n\r\n            Log.d(\"json\", registrationIds.toString())\r\n\r\n            //Request\r\n            val endPoint = URL(\"https://fcm.googleapis.com/fcm/notification\")\r\n\r\n            //Establish a connection\r\n            val httpsURLConnection: HttpsURLConnection =\r\n                endPoint.openConnection() as HttpsURLConnection\r\n\r\n            //Connection to fcm\r\n            //The time available to read from the input stream when the connection is established\r\n            httpsURLConnection.readTimeout = 10000\r\n            //The time available to connect to the url\r\n            httpsURLConnection.connectTimeout = 15000\r\n            //Defining the type of request to be made to the fcm\r\n            httpsURLConnection.requestMethod = \"POST\"\r\n            //Defining that the url connection can be used to send and receive data\r\n            httpsURLConnection.doInput = true\r\n            httpsURLConnection.doOutput = true\r\n\r\n            // Build parameters for json\r\n            httpsURLConnection.setRequestProperty(\"Content-Type\", \"application/json\")\r\n            val project_key = \"AAAAMMR-Gaw:APA91bFeijRa909_QEdEFsQeDSaJZRYD7rOk8B8Bc2QiYcGoyLG1xqqpZLkOJXmZrG0FbScojvqBCsweSEWDrMLM6kr67boS-BVB2oy7fL6Zn1N9ICVk6efGniauDa3z8eaOb1TENmEs\"\r\n            val senderId = \"209455028652\"\r\n            httpsURLConnection.setRequestProperty(\"authorization\", \"key=$project_key\")\r\n            httpsURLConnection.setRequestProperty(\"project_id\", senderId)\r\n\r\n            val json = JSONObject()\r\n\r\n            json.put(\"operation\", \"create\")\r\n            json.put(\"notification_key_name\", notificationKeyName)\r\n            json.put(\"registration_ids\", registrationIds)\r\n\r\n\r\n            // Writer\r\n            val outputStream: OutputStream =\r\n                BufferedOutputStream(httpsURLConnection.outputStream)\r\n            val writer = BufferedWriter(OutputStreamWriter(outputStream, \"utf-8\"))\r\n\r\n            // POST\r\n            writer.write(json.toString())\r\n            writer.flush()\r\n            writer.close()\r\n\r\n            outputStream.close()\r\n\r\n            //The response code and message of the POST requests\r\n            val responseCode: Int = httpsURLConnection.responseCode\r\n            val responseMessage = httpsURLConnection.responseMessage\r\n\r\n            Log.d(TAG, \"$responseCode $responseMessage\")\r\n\r\n\r\n            // Check server STATUS\r\n            if (responseCode in 400..499) {\r\n                httpsURLConnection.errorStream\r\n            } else {\r\n                httpsURLConnection.inputStream\r\n            }\r\n\r\n            if (responseCode == 200) {\r\n                Log.e(TAG, \"Group Created!!\")\r\n\r\n                val response = httpsURLConnection.inputStream.bufferedReader()\r\n                    .use { it.readText() }  // defaults to UTF-8\r\n                withContext(Dispatchers.Main) {\r\n                    //notification_key\r\n                    val jsonObject  = JSONObject(response)\r\n                    val notificationKey = jsonObject.getString(\"notification_key\")\r\n                    println(\"NotifKey: $notificationKey\")\r\n                    Log.d(\"NotifKey\", notificationKey)\r\n                }\r\n            } else {\r\n                Log.e(TAG, \"Error it didn´t work\")\r\n            }\r\n\r\n            //Here i close the connection to the endPoint\r\n            httpsURLConnection.disconnect()\r\n\r\n\r\n        } catch (e: Exception) {\r\n            e.printStackTrace()\r\n        }\r\n    }\r\n\r\n    //This function sends push notifications to devices that are subscribed to a specific topic\r\n    private suspend fun sendNotificationToGroup(title: String, message: String, notificationKey : String) {\r\n\r\n        delay(1500)\r\n\r\n        try {\r\n\r\n            //Request\r\n            val url = URL(\"https://fcm.googleapis.com/fcm/send\")\r\n\r\n            //Establish a connection\r\n            val httpsURLConnection: HttpsURLConnection =\r\n                url.openConnection() as HttpsURLConnection\r\n\r\n            //The time available to read from the input stream when the connection is established\r\n            httpsURLConnection.readTimeout = 10000\r\n            //The time available to connect to the url\r\n            httpsURLConnection.connectTimeout = 15000\r\n            //Defining the type of request to be made to the fcm\r\n            httpsURLConnection.requestMethod = \"POST\"\r\n            //Defining that the url connection can be used to send and receive data\r\n            httpsURLConnection.doInput = true\r\n            httpsURLConnection.doOutput = true\r\n\r\n            // Config of FCM\r\n            val project_key = \"AAAAMMR-Gaw:APA91bFeijRa909_QEdEFsQeDSaJZRYD7rOk8B8Bc2QiYcGoyLG1xqqpZLkOJXmZrG0FbScojvqBCsweSEWDrMLM6kr67boS-BVB2oy7fL6Zn1N9ICVk6efGniauDa3z8eaOb1TENmEs\"\r\n            httpsURLConnection.setRequestProperty(\"authorization\", \"key=$project_key\")\r\n            httpsURLConnection.setRequestProperty(\"Content-Type\", \"application/json\")\r\n\r\n            val jsonObject = JSONObject()\r\n            val data = JSONObject()\r\n\r\n            data.put(\"title\", title)\r\n            data.put(\"content\", message)\r\n            //On Notification Click Activity\r\n            data.put(\"click_action\", \".LoginActivity\")\r\n\r\n            //jsonObject for POST\r\n            jsonObject.put(\"data\", data)\r\n            //\r\n            jsonObject.put(\"to\", notificationKey)\r\n\r\n            val outputStream: OutputStream =\r\n                BufferedOutputStream(httpsURLConnection.outputStream)\r\n            val writer = BufferedWriter(OutputStreamWriter(outputStream, \"utf-8\"))\r\n            \r\n            writer.write(jsonObject.toString())\r\n            writer.flush()\r\n            writer.close()\r\n\r\n            outputStream.close()\r\n\r\n            //The response code and message of the POST requests\r\n            val responseCode: Int = httpsURLConnection.responseCode\r\n            val responseMessage: String = httpsURLConnection.responseMessage\r\n\r\n\r\n            Log.d(TAG, \"Response from sendMes: $responseCode $responseMessage\")\r\n\r\n\r\n            // Check server STATUS\r\n            if (responseCode in 400..499) {\r\n                httpsURLConnection.errorStream\r\n            } else {\r\n                httpsURLConnection.inputStream\r\n            }\r\n            if (responseCode == 200) {\r\n                Log.e(\r\n                    TAG,\r\n                    \"Notification Sent \\n Title: $title \\n Body: $message\"\r\n                )\r\n            } else {\r\n                Log.e(TAG, \"Notification Error\")\r\n            }\r\n\r\n            httpsURLConnection.disconnect()\r\n\r\n        } catch (e: Exception) {\r\n            e.printStackTrace()\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/singularity/ipcaplus/chat/ChatActivity.kt b/app/src/main/java/com/singularity/ipcaplus/chat/ChatActivity.kt
--- a/app/src/main/java/com/singularity/ipcaplus/chat/ChatActivity.kt	(revision d7d49fadf70fadd33042282dce690a6bd606ece4)
+++ b/app/src/main/java/com/singularity/ipcaplus/chat/ChatActivity.kt	(date 1642079549061)
@@ -32,6 +32,7 @@
 import com.singularity.ipcaplus.models.Message
 import com.singularity.ipcaplus.utils.Backend
 import com.singularity.ipcaplus.utils.Backend.createJsonArrayString
+import com.singularity.ipcaplus.utils.Backend.getIv
 import kotlinx.coroutines.*
 import org.json.JSONArray
 import org.json.JSONObject
@@ -126,39 +127,43 @@
                 // get data of ecripted shared preferences ("chatuid" -> "key")
                 val keygen = getMetaOx(this, chat_id)
                 // Build encryptation data of message send by the user
-                var meta = encryptMeta( binding.editTextMessage.text.toString(), keygen.toString())
-                val savedText = binding.editTextMessage.text.toString()
+                getIv(chat_id) {
+
+                    var meta = encryptMeta( binding.editTextMessage.text.toString(), keygen.toString(), it.toString())
+                    val savedText = binding.editTextMessage.text.toString()
 
-                val message = Message(
-                    Firebase.auth.currentUser!!.uid,
-                    meta.toString(),
-                    Timestamp.now(),
-                    ""
+                    val message = Message(
+                        Firebase.auth.currentUser!!.uid,
+                        meta.toString(),
+                        Timestamp.now(),
+                        ""
 
-                )
-                db.collection("chat").document("$chat_id").collection("message")
-                    .add(message.toHash())
-                    .addOnSuccessListener { documentReference ->
+                    )
+                    db.collection("chat").document("$chat_id").collection("message")
+                        .add(message.toHash())
+                        .addOnSuccessListener { documentReference ->
 
-                        GlobalScope.launch {
-                            withContext(Dispatchers.IO){
-                                //APA91bEKDInIYA242YofpahBmhB57pEI4gNT63DJJenWCccJGqeSYrWzj0BSruX49DhVp2vGSY5xJ2fEJk2vhtoraT3_bbjEKw4Nx3eJKj7tttVRPjQs0Uc_OPkrcj4twR70H5tAilnY
-                                println("AVEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE"+ savedText)
-                                sendNotificationToGroup( chat_id, savedText, "APA91bGaOoMTjTD2s9MU63F1AvLqP6tkwdAFE0Mqs9jbghlSgcWlfe_38CboFiE2iiWFoKqNRwhF0G_TA5X9xegTL0_Tg0OGuFadJuBj1sGZqjqCcmF1EH2ZeRU7ySHosdNkmLmmOyFF")
-                            }
-                        }
-                        Log.d(TAG, "DocumentSnapshot added with ID: ${documentReference.id}")
+                            GlobalScope.launch {
+                                withContext(Dispatchers.IO){
+                                    //APA91bEKDInIYA242YofpahBmhB57pEI4gNT63DJJenWCccJGqeSYrWzj0BSruX49DhVp2vGSY5xJ2fEJk2vhtoraT3_bbjEKw4Nx3eJKj7tttVRPjQs0Uc_OPkrcj4twR70H5tAilnY
+                                    println("AVEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE"+ savedText)
+                                    sendNotificationToGroup( chat_id, savedText, "APA91bGaOoMTjTD2s9MU63F1AvLqP6tkwdAFE0Mqs9jbghlSgcWlfe_38CboFiE2iiWFoKqNRwhF0G_TA5X9xegTL0_Tg0OGuFadJuBj1sGZqjqCcmF1EH2ZeRU7ySHosdNkmLmmOyFF")
+                                }
+                            }
+                            Log.d(TAG, "DocumentSnapshot added with ID: ${documentReference.id}")
 
 
-                    }
-                    .addOnFailureListener { e ->
-                        Log.w(TAG, "Error adding document", e)
-                    }
-                binding.editTextMessage.text.clear()
+                        }
+                        .addOnFailureListener { e ->
+                            Log.w(TAG, "Error adding document", e)
+                        }
+                    binding.editTextMessage.text.clear()
 
-            }
-        }
+                }
+            }
 
+        }
+
         // Show Messages
         db.collection("chat").document("$chat_id").collection("message").orderBy("time", Query.Direction.DESCENDING)
             .addSnapshotListener { documents, e ->
@@ -285,32 +290,34 @@
 
                 timeLastMessage?.isVisible = false
                 val keygen = getMetaOx(context, chat_id)
-                val message_decripted = decryptWithAESmeta(keygen.toString(), messages[position].message)
+                getIv(chat_id){
+                    val message_decripted = decryptWithAESmeta(keygen.toString(), messages[position].message, it.toString())
 
-               /* if (otherUser) {
-                        Backend.getUserProfile(messages[position].user) {
-                            val userName = Utilis.getFirstAndLastName(it.name)
-                            textViewUsername.text = userName
-                        }
-                    }
-                */
+                    /* if (otherUser) {
+                             Backend.getUserProfile(messages[position].user) {
+                                 val userName = Utilis.getFirstAndLastName(it.name)
+                                 textViewUsername.text = userName
+                             }
+                         }
+                     */
 
-                textViewMessage.text = message_decripted
-                println(message_decripted)
-                if(position == messages.size - 1) {
-                    val data = Utilis.getDate(
-                        messages[position].time.seconds * 1000,
-                        "yyyy-MM-dd'T'HH:mm:ss.SSS"
-                    )
-                    timeLastMessage.isVisible = true
-                    timeLastMessage.text = Utilis.getHours(data) + ":" + Utilis.getMinutes(data)
-                }
+                    textViewMessage.text = message_decripted
+                    println(message_decripted)
+                    if(position == messages.size - 1) {
+                        val data = Utilis.getDate(
+                            messages[position].time.seconds * 1000,
+                            "yyyy-MM-dd'T'HH:mm:ss.SSS"
+                        )
+                        timeLastMessage.isVisible = true
+                        timeLastMessage.text = Utilis.getHours(data) + ":" + Utilis.getMinutes(data)
+                    }
 
-                if (otherUser) {
-                    val imageViewUser = findViewById<ImageView?>(R.id.imageViewUser)
-                    if (imageViewUser != null) {
-                        Utilis.getFile(context, "profilePictures/${messages[position].user}.png", "png") { bitmap ->
-                            imageViewUser.setImageBitmap(bitmap)
+                    if (otherUser) {
+                        val imageViewUser = findViewById<ImageView?>(R.id.imageViewUser)
+                        if (imageViewUser != null) {
+                            Utilis.getFile(context, "profilePictures/${messages[position].user}.png", "png") { bitmap ->
+                                imageViewUser.setImageBitmap(bitmap)
+                            }
                         }
                     }
                 }
Index: app/src/main/java/com/singularity/ipcaplus/chat/CreateDirectChatActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.singularity.ipcaplus.chat\r\n\r\nimport android.content.ContentValues\r\nimport android.content.Intent\r\nimport android.net.Uri\r\nimport androidx.appcompat.app.AppCompatActivity\r\nimport android.os.Bundle\r\nimport android.util.Log\r\nimport android.view.Menu\r\nimport android.view.MenuInflater\r\nimport com.google.firebase.Timestamp\r\nimport com.google.firebase.auth.ktx.auth\r\nimport com.google.firebase.firestore.ktx.firestore\r\nimport com.google.firebase.ktx.Firebase\r\nimport com.singularity.ipcaplus.R\r\nimport com.singularity.ipcaplus.cryptography.metaGenrateKey\r\nimport com.singularity.ipcaplus.databinding.ActivityCreateChatBinding\r\nimport com.singularity.ipcaplus.drawer.DrawerActivty\r\nimport com.singularity.ipcaplus.models.Chat\r\nimport com.singularity.ipcaplus.models.Message\r\nimport com.singularity.ipcaplus.utils.ActivityImageHelper\r\nimport com.singularity.ipcaplus.utils.Backend\r\nimport com.singularity.ipcaplus.utils.Utilis\r\nimport com.singularity.ipcaplus.utils.Utilis.buildSystemMessage\r\nimport com.theartofdev.edmodo.cropper.CropImage\r\nimport com.theartofdev.edmodo.cropper.CropImageView\r\n\r\nclass CreateDirectChatActivity : ActivityImageHelper() {\r\n\r\n\r\n    val db = Firebase.firestore\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n\r\n        // Variables\r\n        var chatName : String\r\n\r\n        var type = intent.getStringExtra(\"type\")!!\r\n        var memberIds = intent.getStringArrayListExtra(\"users\")!!\r\n        println(memberIds)\r\n\r\n        // Generate key for chats\r\n        val keygen = metaGenrateKey()\r\n\r\n            Backend.getUserProfile(memberIds[1]) {\r\n\r\n\r\n                chatName = it.name\r\n                println(\"Nome antes\" + chatName)\r\n\r\n                // Chat data\r\n                var chat = Chat(\r\n                    chatName,\r\n                    type,\r\n                    keygen\r\n                )\r\n\r\n                // System message data\r\n                val message = Message(\r\n                    \"system\",\r\n                    buildSystemMessage(keygen),\r\n                    Timestamp.now(),\r\n                    \"\"\r\n\r\n                )\r\n\r\n                val user = HashMap<String, Any>()\r\n                val admin = hashMapOf<String?, Any>(\r\n                    \"admin\" to true\r\n                )\r\n\r\n                db.collection(\"chat\")\r\n                    .add(chat.toHash())\r\n                    .addOnSuccessListener { documentReference ->\r\n                        db.collection(\"chat\")\r\n                            .document(documentReference.id)\r\n                            .collection(\"message\")\r\n                            .add(message.toHash())\r\n                        for (member in memberIds) {\r\n                            println(\"IDSDSDS\" + memberIds)\r\n                            Backend.getUserProfile(memberIds[0]) {\r\n                                if (member == Firebase.auth.currentUser!!.uid) {\r\n                                    println(\"IF\")\r\n                                    // Chat data\r\n                                    chat = Chat(\r\n                                        it.name,\r\n                                        type,\r\n                                        keygen\r\n                                    )\r\n                                }\r\n                                println(\"NOMEEEEE\" + it.name)\r\n\r\n                                db.collection(\"profile\")\r\n                                    .document(member)\r\n                                    .collection(\"chat\")\r\n                                    .document(documentReference.id)\r\n                                    .set(chat)\r\n                                db.collection(\"chat\")\r\n                                    .document(documentReference.id)\r\n                                    .collection(\"user\")\r\n                                    .document(member)\r\n                                    .set(user)\r\n                                db.collection(\"chat\")\r\n                                    .document(documentReference.id)\r\n                                    .collection(\"user\")\r\n                                    .document(member)\r\n                                    .update(admin)\r\n\r\n                            }\r\n\r\n\r\n\r\n                        }\r\n\r\n                    }\r\n                    .addOnFailureListener { e ->\r\n                        Log.w(ContentValues.TAG, \"Error adding document\", e)\r\n                    }\r\n\r\n                val intent = Intent(this, DrawerActivty::class.java)\r\n                startActivity(intent)\r\n\r\n            }\r\n\r\n\r\n        }\r\n    }
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/singularity/ipcaplus/chat/CreateDirectChatActivity.kt b/app/src/main/java/com/singularity/ipcaplus/chat/CreateDirectChatActivity.kt
--- a/app/src/main/java/com/singularity/ipcaplus/chat/CreateDirectChatActivity.kt	(revision d7d49fadf70fadd33042282dce690a6bd606ece4)
+++ b/app/src/main/java/com/singularity/ipcaplus/chat/CreateDirectChatActivity.kt	(date 1642079549076)
@@ -13,6 +13,7 @@
 import com.google.firebase.firestore.ktx.firestore
 import com.google.firebase.ktx.Firebase
 import com.singularity.ipcaplus.R
+import com.singularity.ipcaplus.cryptography.generateRandomIV
 import com.singularity.ipcaplus.cryptography.metaGenrateKey
 import com.singularity.ipcaplus.databinding.ActivityCreateChatBinding
 import com.singularity.ipcaplus.drawer.DrawerActivty
@@ -38,6 +39,7 @@
         var type = intent.getStringExtra("type")!!
         var memberIds = intent.getStringArrayListExtra("users")!!
         println(memberIds)
+        val ivGenerated = generateRandomIV()
 
         // Generate key for chats
         val keygen = metaGenrateKey()
@@ -52,13 +54,14 @@
                 var chat = Chat(
                     chatName,
                     type,
-                    keygen
+                    keygen,
+                    ivGenerated
                 )
 
                 // System message data
                 val message = Message(
                     "system",
-                    buildSystemMessage(keygen),
+                    buildSystemMessage(keygen, ivGenerated),
                     Timestamp.now(),
                     ""
 
@@ -85,7 +88,8 @@
                                     chat = Chat(
                                         it.name,
                                         type,
-                                        keygen
+                                        keygen,
+                                        ivGenerated
                                     )
                                 }
                                 println("NOMEEEEE" + it.name)
Index: app/src/main/java/com/singularity/ipcaplus/utils/Utilis.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.singularity.ipcaplus.utils\r\n\r\nimport android.app.Activity\r\nimport android.app.DownloadManager\r\nimport android.content.Context\r\nimport android.content.Intent\r\nimport android.content.res.Resources\r\nimport android.graphics.Bitmap\r\nimport android.graphics.BitmapFactory\r\nimport android.graphics.drawable.BitmapDrawable\r\nimport android.graphics.drawable.GradientDrawable\r\nimport android.net.Uri\r\nimport android.os.Build\r\nimport android.provider.MediaStore\r\nimport android.util.Log\r\nimport androidx.annotation.RequiresApi\r\nimport com.google.firebase.auth.ktx.auth\r\nimport com.google.firebase.ktx.Firebase\r\nimport com.google.firebase.storage.FirebaseStorage\r\nimport com.google.firebase.storage.StorageReference\r\nimport com.google.firebase.storage.ktx.storage\r\nimport com.singularity.ipcaplus.R\r\nimport com.singularity.ipcaplus.cryptography.encryptMeta\r\nimport java.io.File\r\nimport java.io.IOException\r\nimport java.lang.Exception\r\nimport java.net.URI\r\nimport java.text.SimpleDateFormat\r\nimport java.time.LocalDate\r\nimport java.util.*\r\nimport java.util.regex.Pattern\r\n\r\nimport androidx.core.content.res.ResourcesCompat\r\nimport androidx.core.graphics.drawable.toBitmap\r\nimport com.google.firebase.auth.FirebaseAuth\r\nimport java.io.ByteArrayOutputStream\r\nimport com.singularity.ipcaplus.chat.ChatActivity\r\n\r\n\r\nobject  Utilis {\r\n\r\n    /*\r\n        This function return the current month id\r\n     */\r\n    @RequiresApi(Build.VERSION_CODES.O)\r\n    fun getCurrentMonthId(): Int {\r\n\r\n        val c = LocalDate.now()\r\n        val strArray = Pattern.compile(\"-\").split(c.toString())\r\n\r\n        return strArray[1].toInt()\r\n    }\r\n\r\n    /*\r\n        This function return the current year id\r\n     */\r\n    @RequiresApi(Build.VERSION_CODES.O)\r\n    fun getCurrentYear(): String {\r\n\r\n        val c = LocalDate.now()\r\n        val strArray = Pattern.compile(\"-\").split(c.toString())\r\n\r\n        return strArray[0]\r\n    }\r\n\r\n    @RequiresApi(Build.VERSION_CODES.O)\r\n    fun getYearByCalendarId(id: Int): Int {\r\n\r\n        var count = id\r\n        var result = 2021 - 121 // add 1900\r\n\r\n        while (count > 0) {\r\n            count -= 1\r\n            result ++\r\n        }\r\n\r\n        return result\r\n    }\r\n\r\n    /*\r\n        This function return the month value in string by an id\r\n        @month = month id\r\n     */\r\n    fun getMonthById(month: Int): String {\r\n        return when (month) {\r\n            1 -> \"Janeiro\"\r\n            2 -> \"Fevereiro\"\r\n            3 -> \"Março\"\r\n            4 -> \"Abril\"\r\n            5 -> \"Maio\"\r\n            6 -> \"Junho\"\r\n            7 -> \"Julho\"\r\n            8 -> \"Agosto\"\r\n            9 -> \"Setembro\"\r\n            10 -> \"Outubro\"\r\n            11 -> \"Novembro\"\r\n            12 -> \"Dezembro\"\r\n            else -> \"None\"\r\n        }\r\n    }\r\n\r\n    fun convertHoursStringToInt(strVal: String): Int {\r\n        val strArray = Pattern.compile(\":\").split(strVal)\r\n        val result = strArray[0] + strArray[1]\r\n        return result.toInt()\r\n    }\r\n\r\n    fun getDate(milliSeconds: Long, dateFormat: String?): String {\r\n        // Create a DateFormatter object for displaying date in specified format.\r\n        val formatter = SimpleDateFormat(dateFormat)\r\n\r\n        // Create a calendar object that will convert the date and time value in milliseconds to date.\r\n        val calendar: Calendar = Calendar.getInstance()\r\n        calendar.timeInMillis = milliSeconds\r\n        return formatter.format(calendar.time)\r\n    }\r\n\r\n\r\n    /*\r\n        This function split the date and return only the day\r\n        @date = default date\r\n     */\r\n    fun getDay(dateTime: String): String {\r\n\r\n        // Split the date\r\n        val strArray = Pattern.compile(\"-\").split(dateTime)\r\n        val strArray2 = Pattern.compile(\"T\").split(strArray[2])\r\n\r\n        return strArray2[0]\r\n    }\r\n\r\n\r\n    /*\r\n        This function split the date and return only the month in text\r\n        @date = default date\r\n     */\r\n    fun getMonth(dateTime: String): String {\r\n\r\n        // Split the date\r\n        val strArray = Pattern.compile(\"-\").split(dateTime)\r\n\r\n        return strArray[1].toString()\r\n    }\r\n\r\n\r\n    /*\r\n        This function split the date and return only the year in text\r\n        @date = default date\r\n     */\r\n    fun getYear(dateTime: String): String {\r\n\r\n        // Split the date\r\n        val strArray = Pattern.compile(\"-\").split(dateTime)\r\n\r\n        return strArray[0].toString()\r\n    }\r\n\r\n\r\n    /*\r\n        This function split the date and return only the Hours in text\r\n        @date = default date\r\n     */\r\n    fun getHours(dateTime: String): String {\r\n\r\n        // Split the date\r\n        val strArray = Pattern.compile(\"T\").split(dateTime)\r\n        val strArray2 = Pattern.compile(\":\").split(strArray[1])\r\n\r\n        return strArray2[0].toString()\r\n    }\r\n\r\n\r\n    /*\r\n        This function split the date and return only the Minutes in text\r\n        @date = default date\r\n     */\r\n    fun getMinutes(dateTime: String): String {\r\n\r\n        // Split the date\r\n        val strArray = Pattern.compile(\"T\").split(dateTime)\r\n        val strArray2 = Pattern.compile(\":\").split(strArray[1])\r\n\r\n        return strArray2[1].toString()\r\n    }\r\n\r\n    /*\r\n        This function get the buffer with the name of filename on assets folder\r\n     */\r\n\r\n    fun getJsonDataFromAsset(context: Context, fileName: String): String? {\r\n        val jsonString: String\r\n        try {\r\n            jsonString = context.assets.open(fileName).bufferedReader().use { it.readText() }\r\n        } catch (ioException: IOException) {\r\n            ioException.printStackTrace()\r\n            return null\r\n        }\r\n        return jsonString\r\n    }\r\n\r\n    fun getFirstAndLastName(fullName: String): String {\r\n\r\n        val nameArray = Pattern.compile(\" \").split(fullName)\r\n\r\n        return nameArray[0] + \" \" + nameArray[nameArray.size-1]\r\n    }\r\n\r\n    /*\r\n       ------------------------------------------------ Images ------------------------------------------------\r\n    */\r\n\r\n    fun convertDrawableToBitmap(context: Context, drawable: Int): Bitmap {\r\n        return BitmapFactory.decodeResource(context.resources, R.drawable.circle)\r\n    }\r\n\r\n\r\n    fun getFile(context: Context, path: String, suffix: String, callback:(Bitmap)->Unit) {\r\n\r\n        // Retrieve image from firebase\r\n        val storageRef = FirebaseStorage.getInstance().reference.child(path)\r\n        val localfile = File.createTempFile(\"tempImage\", suffix)\r\n\r\n        // Set ImageView\r\n        storageRef.getFile(localfile).addOnSuccessListener {\r\n            val bitmap = BitmapFactory.decodeFile(localfile.absolutePath)\r\n            callback(bitmap)\r\n        }.addOnFailureListener {\r\n            val bitmap = (ResourcesCompat.getDrawable(\r\n                context.resources,\r\n                R.drawable.circle,\r\n                null\r\n            ) as GradientDrawable?)!!.toBitmap()\r\n            callback(bitmap)\r\n        }\r\n\r\n    }\r\n\r\n    fun downloadFile(context: Context, fileName: String, fileExtension: String, destinationDirectory: String, uri: Uri) {\r\n\r\n        val downloadManager = context.getSystemService(Context.DOWNLOAD_SERVICE) as DownloadManager\r\n        val request = DownloadManager.Request(uri)\r\n\r\n        request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED)\r\n        request.setDestinationInExternalPublicDir(destinationDirectory, fileName + fileExtension)\r\n\r\n        downloadManager.enqueue(request)\r\n    }\r\n\r\n\r\n    fun uploadFile(filePath: Uri, targetPath: String) {\r\n\r\n        val storage = Firebase.storage\r\n        val storageRef = storage.reference\r\n\r\n        if (filePath != Uri.EMPTY) {\r\n            val ref: StorageReference = storageRef.child(targetPath)\r\n            ref.putFile(filePath)\r\n        }\r\n    }\r\n\r\n\r\n    fun getFileIcon(fileName:String): Int {\r\n        return if (fileName.contains(\".\")) {\r\n\r\n            val extensionArray = Pattern.compile(\"[.]\").split(fileName)\r\n            val extension = extensionArray[extensionArray.size-1]\r\n\r\n            when (extension) {\r\n                \"png\", \"jpg\", \"jpeg\", \"jep\", \"jfif\", \"gif\" -> R.drawable.ic_picture\r\n                \"invisible\" -> -1\r\n                else -> R.drawable.ic_file\r\n            }\r\n\r\n        } else\r\n            -1\r\n    }\r\n\r\n\r\n    fun uniqueImageNameGen(): String {\r\n        val characters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!#$$%&/()=@[]{}\"\r\n\r\n        val sb = StringBuilder(15)\r\n\r\n        for(x in 0 until 15){\r\n            val random = (characters.indices).random()\r\n            sb.append(characters[random])\r\n        }\r\n\r\n        return sb.toString()\r\n    }\r\n\r\n\r\n    /*\r\n        This function gets the domain of email\r\n        split remove the @ and make the array like this -> [a20115][alunos.ipca.pt]\r\n     */\r\n    fun getEmailDomain(email: String) : String{\r\n        val strArray = Pattern.compile(\"@\").split(email)\r\n        val result= strArray[1]\r\n\r\n        return result.toString()\r\n\r\n    }\r\n\r\n    /*\r\n        ------------------------------------------------ Chat ------------------------------------------------\r\n     */\r\n\r\n    /*\r\n       This function returns the encrypted system message\r\n       @callBack = return the list\r\n    */\r\n    fun buildSystemMessage(key: String) : String {\r\n\r\n        // Build encryptation data of first message send by the system\r\n        var message = encryptMeta(\"This chat is being encripted with Singularity Encryption!\", key)\r\n\r\n        return message.toString()\r\n\r\n    }\r\n\r\n    // Que merda é esta :v\r\n    fun getUID(): String? {\r\n        val firebaseAuth = FirebaseAuth.getInstance()\r\n        return firebaseAuth.uid\r\n    }\r\n\r\n    fun calculateInSampleSize(options: BitmapFactory.Options, reqWidth: Int, reqHeight: Int): Int {\r\n        // Raw height and width of image\r\n        val (height: Int, width: Int) = options.run { outHeight to outWidth }\r\n        var inSampleSize = 1\r\n\r\n        if (height > reqHeight || width > reqWidth) {\r\n\r\n            val halfHeight: Int = height / 2\r\n            val halfWidth: Int = width / 2\r\n\r\n            // Calculate the largest inSampleSize value that is a power of 2 and keeps both\r\n            // height and width larger than the requested height and width.\r\n            while (halfHeight / inSampleSize >= reqHeight && halfWidth / inSampleSize >= reqWidth) {\r\n                inSampleSize *= 2\r\n            }\r\n        }\r\n\r\n        return inSampleSize\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/singularity/ipcaplus/utils/Utilis.kt b/app/src/main/java/com/singularity/ipcaplus/utils/Utilis.kt
--- a/app/src/main/java/com/singularity/ipcaplus/utils/Utilis.kt	(revision d7d49fadf70fadd33042282dce690a6bd606ece4)
+++ b/app/src/main/java/com/singularity/ipcaplus/utils/Utilis.kt	(date 1642079549049)
@@ -310,10 +310,10 @@
        This function returns the encrypted system message
        @callBack = return the list
     */
-    fun buildSystemMessage(key: String) : String {
+    fun buildSystemMessage(key: String, iv : String) : String {
 
         // Build encryptation data of first message send by the system
-        var message = encryptMeta("This chat is being encripted with Singularity Encryption!", key)
+        var message = encryptMeta("This chat is being encripted with Singularity Encryption!", key, iv)
 
         return message.toString()
 
Index: app/src/main/java/com/singularity/ipcaplus/chat/ChatsFragment.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.singularity.ipcaplus.chat\r\n\r\nimport android.content.Intent\r\nimport android.os.Build\r\nimport android.os.Bundle\r\nimport androidx.fragment.app.Fragment\r\nimport android.view.LayoutInflater\r\nimport android.view.View\r\nimport android.view.ViewGroup\r\nimport android.widget.ImageView\r\nimport android.widget.TextView\r\nimport androidx.annotation.RequiresApi\r\nimport androidx.recyclerview.widget.DefaultItemAnimator\r\nimport androidx.recyclerview.widget.LinearLayoutManager\r\nimport androidx.recyclerview.widget.RecyclerView\r\nimport com.google.firebase.auth.ktx.auth\r\nimport com.google.firebase.firestore.ktx.firestore\r\nimport com.google.firebase.ktx.Firebase\r\nimport com.singularity.ipcaplus.utils.Backend\r\nimport com.singularity.ipcaplus.R\r\nimport com.singularity.ipcaplus.cryptography.decryptWithAESmeta\r\nimport com.singularity.ipcaplus.cryptography.getMetaOx\r\nimport com.singularity.ipcaplus.utils.Utilis\r\nimport com.singularity.ipcaplus.cryptography.saveKeygenOx\r\nimport com.singularity.ipcaplus.databinding.FragmentChatsBinding\r\nimport com.singularity.ipcaplus.models.Chat\r\n\r\n\r\nclass ChatsFragment : Fragment() {\r\n\r\n    // Variables\r\n    var chats = arrayListOf<Chat>()\r\n    var chatIds = arrayListOf<String>()\r\n\r\n    private var _binding: FragmentChatsBinding? = null\r\n    private var mAdapter: RecyclerView.Adapter<*>? = null\r\n    private var mLayoutManager: LinearLayoutManager? = null\r\n\r\n    private val binding get() = _binding!!\r\n\r\n    val db = Firebase.firestore\r\n\r\n    override fun onCreateView(\r\n        inflater: LayoutInflater, container: ViewGroup?,\r\n        savedInstanceState: Bundle?\r\n    ): View? {\r\n\r\n\r\n        _binding = FragmentChatsBinding.inflate(layoutInflater)\r\n        val root: View = binding.root\r\n\r\n        // Get Group Chats\r\n        db.collection(\"profile\").document(\"${Firebase.auth.currentUser!!.uid}\").collection(\"chat\")\r\n            .addSnapshotListener { documents, e ->\r\n                documents?.let {\r\n                    chats.clear()\r\n                    chatIds.clear()\r\n                    for (document in it) {\r\n                        val chat = Chat.fromHash(document)\r\n                        if (chat.type == \"chat\") {\r\n                            chats.add(chat)\r\n                            chatIds.add(document.id)\r\n                        }\r\n                    }\r\n                    mAdapter?.notifyDataSetChanged()\r\n                }\r\n            }\r\n\r\n        // RecyclerView Chat\r\n        mLayoutManager = LinearLayoutManager(activity, LinearLayoutManager.VERTICAL, false)\r\n        binding.recyclerViewGroups.layoutManager = mLayoutManager\r\n        mAdapter = ChatAdapter()\r\n        binding.recyclerViewGroups.itemAnimator = DefaultItemAnimator()\r\n        binding.recyclerViewGroups.adapter = mAdapter\r\n\r\n        return root\r\n    }\r\n\r\n    /*\r\n        Refresh Activity Content\r\n    */\r\n    override fun onResume() {\r\n        super.onResume()\r\n\r\n        // Get Group Chats\r\n        db.collection(\"profile\").document(\"${Firebase.auth.currentUser!!.uid}\").collection(\"chat\")\r\n            .addSnapshotListener { documents, e ->\r\n                documents?.let {\r\n                    chats.clear()\r\n                    chatIds.clear()\r\n                    for (document in it) {\r\n                        val chat = Chat.fromHash(document)\r\n                        if (chat.type == \"chat\" || chat.type == \"group\") {\r\n                            chats.add(chat)\r\n                            chatIds.add(document.id)\r\n                        }\r\n                    }\r\n                    println(\"CHAT \" + chats)\r\n                    mAdapter?.notifyDataSetChanged()\r\n                }\r\n            }\r\n\r\n    }\r\n\r\n\r\n    override fun onDestroyView() {\r\n        super.onDestroyView()\r\n        _binding = null\r\n    }\r\n\r\n\r\n    inner class ChatAdapter : RecyclerView.Adapter<ChatAdapter.ViewHolder>() {\r\n\r\n        inner class ViewHolder(val v: View) : RecyclerView.ViewHolder(v)\r\n\r\n        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {\r\n                return ViewHolder(\r\n                    LayoutInflater.from(parent.context).inflate(R.layout.row_chat, parent, false)\r\n                )\r\n\r\n        }\r\n\r\n        @RequiresApi(Build.VERSION_CODES.M)\r\n        override fun onBindViewHolder(holder: ViewHolder, position: Int) {\r\n\r\n                holder.v.apply {\r\n\r\n                    // Variables\r\n                    val textViewMessage = findViewById<TextView>(R.id.textViewChatName)\r\n                    val imageViewChatGroup = findViewById<ImageView>(R.id.imageViewChatGroup)\r\n                    val lastMessageTime = findViewById<TextView>(R.id.lastMessageTime)\r\n                    val lastMessageText = findViewById<TextView>(R.id.textViewLastMessage)\r\n\r\n\r\n                    textViewMessage.text = chats[position].name\r\n\r\n                    // sync data recieved form direbase with encrypted shared preferences (key -> 1x)\r\n                    saveKeygenOx(context, chatIds[position], chats[position].ox.toString())\r\n                    // Set Last Chat Message\r\n                    Backend.getLastMessageByChatID(chatIds[position]) {\r\n                        val data = Utilis.getDate(it!!.time.seconds *1000, \"yyyy-MM-dd'T'HH:mm:ss.SSS\")\r\n                        lastMessageTime.text = Utilis.getHours(data) + \":\" + Utilis.getMinutes(data)\r\n                        val keygen = getMetaOx(context, chatIds[position])\r\n                        val message_decripted = decryptWithAESmeta(keygen.toString(), it.message)\r\n                        lastMessageText.text = message_decripted\r\n                    }\r\n\r\n                    Utilis.getFile(this.context, \"chats/${chatIds[position]}/icon.png\", \"png\") { bitmap ->\r\n                        imageViewChatGroup.setImageBitmap(bitmap)\r\n                    }\r\n\r\n                }\r\n                holder.v.setOnClickListener {\r\n                    val intent = Intent(activity, ChatActivity::class.java)\r\n                    intent.putExtra(\"chat_id\", chatIds[position])\r\n                    activity?.startActivity(intent)\r\n                }\r\n\r\n        }\r\n\r\n        override fun getItemViewType(position: Int) : Int {\r\n            if (chats[position].type == \"group\") {\r\n                return 1\r\n            } else {\r\n                return 0\r\n            }\r\n        }\r\n\r\n        override fun getItemCount(): Int {\r\n            return chats.size\r\n        }\r\n    }\r\n\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/singularity/ipcaplus/chat/ChatsFragment.kt b/app/src/main/java/com/singularity/ipcaplus/chat/ChatsFragment.kt
--- a/app/src/main/java/com/singularity/ipcaplus/chat/ChatsFragment.kt	(revision d7d49fadf70fadd33042282dce690a6bd606ece4)
+++ b/app/src/main/java/com/singularity/ipcaplus/chat/ChatsFragment.kt	(date 1642079549072)
@@ -24,6 +24,7 @@
 import com.singularity.ipcaplus.cryptography.saveKeygenOx
 import com.singularity.ipcaplus.databinding.FragmentChatsBinding
 import com.singularity.ipcaplus.models.Chat
+import com.singularity.ipcaplus.utils.Backend.getIv
 
 
 class ChatsFragment : Fragment() {
@@ -138,13 +139,18 @@
                     saveKeygenOx(context, chatIds[position], chats[position].ox.toString())
                     // Set Last Chat Message
                     Backend.getLastMessageByChatID(chatIds[position]) {
+
                         val data = Utilis.getDate(it!!.time.seconds *1000, "yyyy-MM-dd'T'HH:mm:ss.SSS")
                         lastMessageTime.text = Utilis.getHours(data) + ":" + Utilis.getMinutes(data)
+
                         val keygen = getMetaOx(context, chatIds[position])
-                        val message_decripted = decryptWithAESmeta(keygen.toString(), it.message)
-                        lastMessageText.text = message_decripted
-                    }
+                        getIv(chatIds[position]){iv ->
+                            val message_decripted = decryptWithAESmeta(keygen.toString(), it.message, iv.toString())
+                            lastMessageText.text = message_decripted
+                        }
 
+                    }
+
                     Utilis.getFile(this.context, "chats/${chatIds[position]}/icon.png", "png") { bitmap ->
                         imageViewChatGroup.setImageBitmap(bitmap)
                     }
Index: app/src/main/java/com/singularity/ipcaplus/chat/CreateChatActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.singularity.ipcaplus.chat\r\n\r\nimport android.content.ContentValues\r\nimport android.content.Intent\r\nimport android.net.Uri\r\nimport androidx.appcompat.app.AppCompatActivity\r\nimport android.os.Bundle\r\nimport android.util.Log\r\nimport android.view.Menu\r\nimport android.view.MenuInflater\r\nimport android.widget.ImageView\r\nimport com.google.firebase.Timestamp\r\nimport com.google.firebase.auth.ktx.auth\r\nimport com.google.firebase.firestore.ktx.firestore\r\nimport com.google.firebase.ktx.Firebase\r\nimport com.singularity.ipcaplus.R\r\nimport com.singularity.ipcaplus.cryptography.metaGenrateKey\r\nimport com.singularity.ipcaplus.databinding.ActivityCreateChatBinding\r\nimport com.singularity.ipcaplus.drawer.DrawerActivty\r\nimport com.singularity.ipcaplus.models.Chat\r\nimport com.singularity.ipcaplus.models.Message\r\nimport com.singularity.ipcaplus.utils.ActivityImageHelper\r\nimport com.singularity.ipcaplus.utils.Backend\r\nimport com.singularity.ipcaplus.utils.Utilis\r\nimport com.singularity.ipcaplus.utils.Utilis.buildSystemMessage\r\nimport com.theartofdev.edmodo.cropper.CropImage\r\nimport com.theartofdev.edmodo.cropper.CropImageView\r\n\r\nclass CreateChatActivity : ActivityImageHelper() {\r\n\r\n    // Variables\r\n    private lateinit var binding: ActivityCreateChatBinding\r\n    var uri = Uri.EMPTY\r\n\r\n    val db = Firebase.firestore\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_create_chat)\r\n\r\n        binding = ActivityCreateChatBinding.inflate(layoutInflater)\r\n        setContentView(binding.root)\r\n\r\n        // Variables\r\n        var chatName : String\r\n\r\n        var type = intent.getStringExtra(\"type\")!!\r\n        var memberIds = intent.getStringArrayListExtra(\"users\")!!\r\n\r\n        // Generate key for chats\r\n        val keygen = metaGenrateKey()\r\n\r\n        binding.imageViewChatPhoto.setOnClickListener {\r\n            checkPermission(android.Manifest.permission.READ_EXTERNAL_STORAGE, STORAGE_PERMISSION_CODE)\r\n        }\r\n\r\n\r\n            // Create Chat\r\n            binding.fabCreateChat.setOnClickListener {\r\n\r\n\r\n                chatName = binding.editTextChatName.text.toString()\r\n\r\n                // Chat data\r\n                val chat = Chat(\r\n                    chatName,\r\n                    type.toString(),\r\n                    keygen\r\n                )\r\n\r\n                // System message data\r\n                val message = Message(\r\n                    \"system\",\r\n                    buildSystemMessage(keygen),\r\n                    Timestamp.now(),\r\n                    \"\"\r\n\r\n                )\r\n\r\n                val user = HashMap<String, Any>()\r\n                val admin = hashMapOf<String?, Any>(\r\n                    \"admin\" to true\r\n                )\r\n\r\n                db.collection(\"chat\")\r\n                    .add(chat.toHash())\r\n                    .addOnSuccessListener { documentReference ->\r\n                        db.collection(\"chat\")\r\n                            .document(documentReference.id)\r\n                            .collection(\"message\")\r\n                            .add(message.toHash())\r\n                        for (member in memberIds) {\r\n                            db.collection(\"profile\")\r\n                                .document(member)\r\n                                .collection(\"chat\")\r\n                                .document(documentReference.id)\r\n                                .set(chat)\r\n                            db.collection(\"chat\")\r\n                                .document(documentReference.id)\r\n                                .collection(\"user\")\r\n                                .document(member)\r\n                                .set(user)\r\n                            if (member == Firebase.auth.currentUser!!.uid) {\r\n                                db.collection(\"chat\")\r\n                                    .document(documentReference.id)\r\n                                    .collection(\"user\")\r\n                                    .document(member)\r\n                                    .update(admin)\r\n                            }\r\n                            if (uri != Uri.EMPTY)\r\n                                Utilis.uploadFile(uri, \"chats/${documentReference.id}/icon.png\")\r\n\r\n                        }\r\n\r\n                    }\r\n                    .addOnFailureListener { e ->\r\n                        Log.w(ContentValues.TAG, \"Error adding document\", e)\r\n                    }\r\n\r\n                val intent = Intent(this, DrawerActivty::class.java)\r\n                startActivity(intent)\r\n\r\n            }\r\n\r\n    }\r\n    /*\r\n       This function happen after picking photo, and make changes in the activity\r\n    */\r\n    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\r\n        super.onActivityResult(requestCode, resultCode, data)\r\n\r\n        if(requestCode == IMAGE_REQUEST_CODE && resultCode == RESULT_OK){\r\n            CropImage.activity(data?.data)\r\n                .setGuidelines(CropImageView.Guidelines.ON)\r\n                .setAspectRatio(1,1)\r\n                .start(this)\r\n        }\r\n\r\n        if (requestCode == CropImage.CROP_IMAGE_ACTIVITY_REQUEST_CODE) {\r\n            val result = CropImage.getActivityResult(data)\r\n            if (resultCode == RESULT_OK) {\r\n                binding.imageViewChatPhoto.setImageURI(result.uri)\r\n                uri = result.uri\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n       This function create the action bar above the activity\r\n    */\r\n    override fun onCreateOptionsMenu(menu: Menu): Boolean {\r\n        val inflater: MenuInflater = menuInflater\r\n        inflater.inflate(R.menu.menu_chat, menu)\r\n        supportActionBar?.setDisplayHomeAsUpEnabled(true)\r\n        supportActionBar?.setHomeAsUpIndicator(R.drawable.ic_arrow_back_24)\r\n\r\n\r\n        return true\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/singularity/ipcaplus/chat/CreateChatActivity.kt b/app/src/main/java/com/singularity/ipcaplus/chat/CreateChatActivity.kt
--- a/app/src/main/java/com/singularity/ipcaplus/chat/CreateChatActivity.kt	(revision d7d49fadf70fadd33042282dce690a6bd606ece4)
+++ b/app/src/main/java/com/singularity/ipcaplus/chat/CreateChatActivity.kt	(date 1642079549065)
@@ -9,11 +9,14 @@
 import android.view.Menu
 import android.view.MenuInflater
 import android.widget.ImageView
+import android.widget.TextView
+import androidx.appcompat.app.ActionBar
 import com.google.firebase.Timestamp
 import com.google.firebase.auth.ktx.auth
 import com.google.firebase.firestore.ktx.firestore
 import com.google.firebase.ktx.Firebase
 import com.singularity.ipcaplus.R
+import com.singularity.ipcaplus.cryptography.generateRandomIV
 import com.singularity.ipcaplus.cryptography.metaGenrateKey
 import com.singularity.ipcaplus.databinding.ActivityCreateChatBinding
 import com.singularity.ipcaplus.drawer.DrawerActivty
@@ -39,6 +42,13 @@
 
         binding = ActivityCreateChatBinding.inflate(layoutInflater)
         setContentView(binding.root)
+        supportActionBar?.displayOptions = ActionBar.DISPLAY_SHOW_CUSTOM
+        supportActionBar?.setCustomView(R.layout.custom_bar_layout)
+        findViewById<TextView>(R.id.AppBarTittle).text = "Novo Grupo"
+        // Back button
+        findViewById<ImageView>(R.id.BackButtonImageView).setOnClickListener{
+            finish()
+        }
 
         // Variables
         var chatName : String
@@ -59,18 +69,20 @@
 
 
                 chatName = binding.editTextChatName.text.toString()
+                val ivGenerated = generateRandomIV()
 
                 // Chat data
                 val chat = Chat(
                     chatName,
                     type.toString(),
-                    keygen
+                    keygen,
+                    ivGenerated
                 )
 
                 // System message data
                 val message = Message(
                     "system",
-                    buildSystemMessage(keygen),
+                    buildSystemMessage(keygen, ivGenerated),
                     Timestamp.now(),
                     ""
 
@@ -144,17 +156,4 @@
             }
         }
     }
-
-    /*
-       This function create the action bar above the activity
-    */
-    override fun onCreateOptionsMenu(menu: Menu): Boolean {
-        val inflater: MenuInflater = menuInflater
-        inflater.inflate(R.menu.menu_chat, menu)
-        supportActionBar?.setDisplayHomeAsUpEnabled(true)
-        supportActionBar?.setHomeAsUpIndicator(R.drawable.ic_arrow_back_24)
-
-
-        return true
-    }
 }
\ No newline at end of file
Index: app/src/main/java/com/singularity/ipcaplus/models/Chat.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.singularity.ipcaplus.models\r\n\r\nimport com.google.firebase.firestore.QueryDocumentSnapshot\r\n\r\nclass Chat {\r\n    var name : String = \"\"\r\n    var type : String = \"\"\r\n    var ox : String? = \"\"\r\n    var id : String? =  null\r\n\r\n    constructor(name : String, type : String, ox : String) {\r\n        this.name = name\r\n        this.type = type\r\n        this.ox = ox\r\n    }\r\n\r\n    fun toHash() :HashMap<String, Any> {\r\n        var hashMap = HashMap<String, Any>()\r\n        hashMap.put(\"name\", name)\r\n        hashMap.put(\"type\", type)\r\n        hashMap.put(\"ox\", ox!!)\r\n        return hashMap\r\n    }\r\n\r\n    companion object {\r\n        fun fromHash(hashMap: QueryDocumentSnapshot) : Chat {\r\n            val chat = Chat(\r\n                hashMap[\"name\"] as String,\r\n                hashMap[\"type\"] as String,\r\n                hashMap[\"ox\"] as String\r\n            )\r\n            return chat\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/singularity/ipcaplus/models/Chat.kt b/app/src/main/java/com/singularity/ipcaplus/models/Chat.kt
--- a/app/src/main/java/com/singularity/ipcaplus/models/Chat.kt	(revision d7d49fadf70fadd33042282dce690a6bd606ece4)
+++ b/app/src/main/java/com/singularity/ipcaplus/models/Chat.kt	(date 1642077007855)
@@ -7,11 +7,13 @@
     var type : String = ""
     var ox : String? = ""
     var id : String? =  null
+    var iv : String? = ""
 
-    constructor(name : String, type : String, ox : String) {
+    constructor(name : String, type : String, ox : String, iv : String) {
         this.name = name
         this.type = type
         this.ox = ox
+        this.iv = iv
     }
 
     fun toHash() :HashMap<String, Any> {
@@ -19,6 +21,7 @@
         hashMap.put("name", name)
         hashMap.put("type", type)
         hashMap.put("ox", ox!!)
+        hashMap.put("iv", iv!!)
         return hashMap
     }
 
@@ -27,7 +30,9 @@
             val chat = Chat(
                 hashMap["name"] as String,
                 hashMap["type"] as String,
-                hashMap["ox"] as String
+                hashMap["ox"] as String,
+                hashMap["iv"] as String
+
             )
             return chat
         }
Index: app/src/main/java/com/singularity/ipcaplus/AddPeopleActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.singularity.ipcaplus\r\n\r\nimport android.content.Intent\r\nimport android.os.Bundle\r\nimport android.view.LayoutInflater\r\nimport android.view.View\r\nimport android.view.ViewGroup\r\nimport android.widget.ImageView\r\nimport android.widget.TextView\r\nimport androidx.appcompat.app.AppCompatActivity\r\nimport androidx.recyclerview.widget.DefaultItemAnimator\r\nimport androidx.recyclerview.widget.LinearLayoutManager\r\nimport androidx.recyclerview.widget.RecyclerView\r\nimport com.google.firebase.auth.ktx.auth\r\nimport com.google.firebase.firestore.ktx.firestore\r\nimport com.google.firebase.ktx.Firebase\r\nimport com.singularity.ipcaplus.chat.CreateChatActivity\r\nimport com.singularity.ipcaplus.databinding.ActivityAddPeopleBinding\r\nimport com.singularity.ipcaplus.models.Chat\r\nimport com.singularity.ipcaplus.models.Profile\r\nimport com.singularity.ipcaplus.utils.Backend\r\nimport com.singularity.ipcaplus.utils.Utilis\r\n\r\nclass AddPeopleActivity: AppCompatActivity() {\r\n\r\n    var users = arrayListOf<Profile>()\r\n    var selectedUsers = arrayListOf<Profile>()\r\n\r\n    private lateinit var binding: ActivityAddPeopleBinding\r\n\r\n    private var userAdapter: RecyclerView.Adapter<*>? = null\r\n    private var userSelectedAdapter: RecyclerView.Adapter<*>? = null\r\n\r\n    private var userLayoutManager: LinearLayoutManager? = null\r\n    private var userSelectedLayoutManager: LinearLayoutManager? = null\r\n\r\n\r\n    val db = Firebase.firestore\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_add_people)\r\n        binding = ActivityAddPeopleBinding.inflate(layoutInflater)\r\n        setContentView(binding.root)\r\n\r\n        binding.backBtn.setOnClickListener {\r\n            finish()\r\n        }\r\n\r\n        // Add people with a chat already created\r\n        if (intent.hasExtra(\"chat_id\")) {\r\n            val chat_id = intent.getStringExtra(\"chat_id\")\r\n            Backend.getAllUsersExceptChatUsers(chat_id!!) {\r\n                users.clear()\r\n                users.addAll(it)\r\n                userAdapter?.notifyDataSetChanged()\r\n            }\r\n\r\n            // Continue button\r\n            binding.fabCreateChat.setOnClickListener {\r\n\r\n                Backend.db.collection(\"chat\")\r\n                    .document(chat_id)\r\n                    .get()\r\n                    .addOnSuccessListener { document ->\r\n\r\n                        val chat = Chat(\r\n                            document[\"name\"] as String,\r\n                            document[\"type\"] as String,\r\n                            document[\"ox\"] as String\r\n                        )\r\n\r\n                        val selectedUsersIds = arrayListOf<String>()\r\n                        for(user in selectedUsers) {\r\n                            selectedUsersIds.add(user.id!!)\r\n                        }\r\n\r\n                        Backend.addUsersIntoChat(chat, chat_id, selectedUsersIds) {\r\n                            finish()\r\n                        }\r\n\r\n                    }\r\n\r\n            }\r\n        }\r\n        // Add people and create chat for the first time\r\n        else {\r\n            Backend.getAllUsersExceptCurrent {\r\n                users.clear()\r\n                users.addAll(it)\r\n                userAdapter?.notifyDataSetChanged()\r\n            }\r\n\r\n            // Continue button\r\n            binding.fabCreateChat.setOnClickListener {\r\n\r\n                val selectedUsersIds = arrayListOf<String>()\r\n                for(user in selectedUsers) {\r\n                    selectedUsersIds.add(user.id!!)\r\n                }\r\n\r\n                // Add current user to users list\r\n                Backend.getUserProfile(Firebase.auth.currentUser!!.uid) {\r\n                    selectedUsersIds.add(it.id!!)\r\n\r\n                    // Send users list to chat creation\r\n                    val intent = Intent(this, CreateChatActivity::class.java)\r\n                    intent.putExtra(\"users\", selectedUsersIds)\r\n                    intent.putExtra(\"type\", \"group\")\r\n                    startActivity(intent)\r\n                }\r\n            }\r\n        }\r\n\r\n        // Recycler View All Users\r\n        userLayoutManager = LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)\r\n        binding.recyclerViewUsers.layoutManager = userLayoutManager\r\n        userAdapter = AllUsersAdapter()\r\n        binding.recyclerViewUsers.itemAnimator = DefaultItemAnimator()\r\n        binding.recyclerViewUsers.adapter = userAdapter\r\n\r\n        // Recycler View Selected Users\r\n        userSelectedLayoutManager = LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false)\r\n        binding.recyclerViewUsersSelected.layoutManager = userSelectedLayoutManager\r\n        userSelectedAdapter = SelectedUsersAdapter()\r\n        binding.recyclerViewUsersSelected.itemAnimator = DefaultItemAnimator()\r\n        binding.recyclerViewUsersSelected.adapter = userSelectedAdapter\r\n\r\n    }\r\n\r\n\r\n    inner class AllUsersAdapter : RecyclerView.Adapter<AllUsersAdapter.ViewHolder>() {\r\n\r\n        inner class ViewHolder(val v: View) : RecyclerView.ViewHolder(v)\r\n\r\n        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {\r\n            return ViewHolder(\r\n                LayoutInflater.from(parent.context).inflate(R.layout.row_user, parent, false)\r\n            )\r\n        }\r\n\r\n        override fun onBindViewHolder(holder: ViewHolder, position: Int) {\r\n\r\n            holder.v.apply {\r\n                // Variables\r\n                val username = findViewById<TextView>(R.id.textViewProfileName)\r\n                val imageViewUser = findViewById<ImageView>(R.id.imageViewProfile)\r\n\r\n                // Set data\r\n                Utilis.getFile(context, \"profilePictures/${users[position].id}.png\", \"png\") { bitmap ->\r\n                    imageViewUser.setImageBitmap(bitmap)\r\n                }\r\n\r\n                username.text = Utilis.getFirstAndLastName(users[position].name)\r\n\r\n            }\r\n            holder.v.setOnClickListener {\r\n\r\n                selectedUsers.add(users[position])\r\n                users.remove(users[position])\r\n                userSelectedAdapter?.notifyDataSetChanged()\r\n                userAdapter?.notifyDataSetChanged()\r\n            }\r\n\r\n        }\r\n\r\n        override fun getItemCount(): Int {\r\n            return users.size\r\n        }\r\n    }\r\n\r\n    inner class SelectedUsersAdapter : RecyclerView.Adapter<SelectedUsersAdapter.ViewHolder>() {\r\n\r\n        inner class ViewHolder(val v: View) : RecyclerView.ViewHolder(v)\r\n\r\n        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {\r\n            return ViewHolder(\r\n                LayoutInflater.from(parent.context).inflate(R.layout.row_add_pp, parent, false)\r\n            )\r\n        }\r\n\r\n        override fun onBindViewHolder(holder: ViewHolder, position: Int) {\r\n\r\n            holder.v.apply {\r\n                // Variables\r\n                val username = findViewById<TextView>(R.id.textViewProfileNameAdd)\r\n                val imageViewUser = findViewById<ImageView>(R.id.imageViewProfile)\r\n\r\n                // Set data\r\n                Utilis.getFile(context,\"profilePictures/${selectedUsers[position].id}.png\", \"png\") { bitmap ->\r\n                    imageViewUser.setImageBitmap(bitmap)\r\n                }\r\n\r\n                username.text = Utilis.getFirstAndLastName(selectedUsers[position].name)\r\n\r\n            }\r\n            holder.v.setOnClickListener {\r\n\r\n                users.add(selectedUsers[position])\r\n                selectedUsers.remove(selectedUsers[position])\r\n                userAdapter?.notifyDataSetChanged()\r\n                userSelectedAdapter?.notifyDataSetChanged()\r\n            }\r\n\r\n        }\r\n\r\n        override fun getItemCount(): Int {\r\n            return selectedUsers.size\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/singularity/ipcaplus/AddPeopleActivity.kt b/app/src/main/java/com/singularity/ipcaplus/AddPeopleActivity.kt
--- a/app/src/main/java/com/singularity/ipcaplus/AddPeopleActivity.kt	(revision d7d49fadf70fadd33042282dce690a6bd606ece4)
+++ b/app/src/main/java/com/singularity/ipcaplus/AddPeopleActivity.kt	(date 1642078572739)
@@ -67,7 +67,8 @@
                         val chat = Chat(
                             document["name"] as String,
                             document["type"] as String,
-                            document["ox"] as String
+                            document["ox"] as String,
+                            document["iv"] as String
                         )
 
                         val selectedUsersIds = arrayListOf<String>()
Index: app/src/main/java/com/singularity/ipcaplus/cryptography/metaData.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.singularity.ipcaplus.cryptography\r\n\r\nimport android.content.Context\r\nimport android.os.Build\r\nimport android.util.Log\r\nimport androidx.annotation.RequiresApi\r\nimport androidx.security.crypto.EncryptedSharedPreferences\r\nimport androidx.security.crypto.MasterKeys\r\nimport com.google.gson.Gson\r\nimport com.google.gson.GsonBuilder\r\nimport org.bouncycastle.jce.provider.BouncyCastleProvider\r\nimport org.bouncycastle.util.encoders.Base64\r\nimport java.io.UnsupportedEncodingException\r\nimport java.security.InvalidKeyException\r\nimport java.security.NoSuchAlgorithmException\r\nimport java.security.SecureRandom\r\nimport java.security.Security\r\nimport java.util.Objects.hash\r\nimport javax.crypto.*\r\nimport javax.crypto.spec.IvParameterSpec\r\nimport javax.crypto.spec.SecretKeySpec\r\n\r\n\r\n\r\n\r\n\r\nfun encryptMeta(strToEncrypt: String, secret_key: String): String? {\r\n    Security.addProvider(BouncyCastleProvider())\r\n    hash(strToEncrypt)\r\n    var keyBytes: ByteArray\r\n    //val initVector = generateRandomIV()\r\n    val initVector = \"7c5afb00aaecb1a1\"\r\n    val iv = IvParameterSpec(initVector.toByteArray(charset(\"UTF-8\")))\r\n    println(\"AVEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE $initVector\")\r\n\r\n\r\n    try {\r\n        keyBytes = secret_key.toByteArray(charset(\"UTF8\"))\r\n        val skey = SecretKeySpec(keyBytes, \"AES\")\r\n        val input = strToEncrypt.toByteArray(charset(\"UTF8\"))\r\n\r\n        synchronized(Cipher::class.java) {\r\n            val cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\")\r\n            cipher.init(Cipher.ENCRYPT_MODE, skey, iv)\r\n\r\n            val cipherText = ByteArray(cipher.getOutputSize(input.size))\r\n            var ctLength = cipher.update(\r\n                input, 0, input.size,\r\n                cipherText, 0\r\n            )\r\n            ctLength += cipher.doFinal(cipherText, ctLength)\r\n            return String(\r\n                Base64.encode(cipherText)\r\n            )\r\n        }\r\n    } catch (uee: UnsupportedEncodingException) {\r\n        uee.printStackTrace()\r\n    } catch (ibse: IllegalBlockSizeException) {\r\n        ibse.printStackTrace()\r\n    } catch (bpe: BadPaddingException) {\r\n        bpe.printStackTrace()\r\n    } catch (ike: InvalidKeyException) {\r\n        ike.printStackTrace()\r\n    } catch (nspe: NoSuchPaddingException) {\r\n        nspe.printStackTrace()\r\n    } catch (nsae: NoSuchAlgorithmException) {\r\n        nsae.printStackTrace()\r\n    } catch (e: ShortBufferException) {\r\n        e.printStackTrace()\r\n    }\r\n\r\n    return null\r\n}\r\n\r\nfun decryptWithAESmeta(key: String, strToDecrypt: String?): String? {\r\n    Security.addProvider(BouncyCastleProvider())\r\n    var keyBytes: ByteArray\r\n    val initVector = \"7c5afb00aaecb1a1\"\r\n\r\n    try {\r\n        val iv = IvParameterSpec(initVector.toByteArray(charset(\"UTF-8\")))\r\n        keyBytes = key.toByteArray(charset(\"UTF8\"))\r\n        val skey = SecretKeySpec(keyBytes, \"AES\")\r\n        val input = org.bouncycastle.util.encoders.Base64\r\n            .decode(strToDecrypt?.trim { it <= ' ' }?.toByteArray(charset(\"UTF8\")))\r\n\r\n        synchronized(Cipher::class.java) {\r\n            val cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\")\r\n            cipher.init(Cipher.DECRYPT_MODE, skey, iv)\r\n\r\n            val plainText = ByteArray(cipher.getOutputSize(input.size))\r\n            var ptLength = cipher.update(input, 0, input.size, plainText, 0)\r\n            ptLength += cipher.doFinal(plainText, ptLength)\r\n            val decryptedString = String(plainText)\r\n            return decryptedString.trim { it <= ' ' }\r\n        }\r\n    } catch (uee: UnsupportedEncodingException) {\r\n        uee.printStackTrace()\r\n    } catch (ibse: IllegalBlockSizeException) {\r\n        ibse.printStackTrace()\r\n    } catch (bpe: BadPaddingException) {\r\n        bpe.printStackTrace()\r\n    } catch (ike: InvalidKeyException) {\r\n        ike.printStackTrace()\r\n    } catch (nspe: NoSuchPaddingException) {\r\n        nspe.printStackTrace()\r\n    } catch (nsae: NoSuchAlgorithmException) {\r\n        nsae.printStackTrace()\r\n    } catch (e: ShortBufferException) {\r\n        e.printStackTrace()\r\n    }\r\n\r\n    return null\r\n}\r\n\r\nfun metaGenrateKey(): String {\r\n    //val secretKey: String = \"662ede816988e58fb6d057d9d85605e0\"\r\n    val keygen = (\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\r\n            + \"0123456789\"\r\n            + \"abcdefghijklmnopqrstuvxyz\")\r\n\r\n    val n = 32\r\n\r\n    // create StringBuffer size of keygen\r\n    val secretKey = StringBuilder(n)\r\n    for (i in 0 until n) {\r\n\r\n        // generate a random number between\r\n        // 0 to keygen variable length\r\n        val index = (keygen.length\r\n                * Math.random()).toInt()\r\n\r\n        // add Character one by one in end of secretKey\r\n        secretKey.append(keygen[index])\r\n\r\n    }\r\n    println(secretKey)\r\n    return secretKey.toString()\r\n}\r\n\r\nfun metaBlock(message: String){\r\n    //val secretKey: String = \"662ede816988e58fb6d057d9d85605e0\"\r\n    val keygen = metaGenrateKey()\r\n\r\n    var meta = encryptMeta(message, keygen)\r\n    println(meta)\r\n\r\n    val message_decripted = decryptWithAESmeta(keygen, meta)\r\n    println(message_decripted)\r\n}\r\n\r\n@RequiresApi(Build.VERSION_CODES.M)\r\nfun saveKeygenOx(context : Context, chatUid : String, keygen: String){\r\n\r\n    val keyGenParameterSpec = MasterKeys.AES256_GCM_SPEC\r\n    val masterKeyAlias = MasterKeys.getOrCreate(keyGenParameterSpec)\r\n    val sharedPreferences = EncryptedSharedPreferences.create(\r\n        \"meta_shared_preferences\",\r\n        masterKeyAlias,\r\n        context,\r\n        EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,\r\n        EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM\r\n    )\r\n\r\n    // storing a value\r\n    sharedPreferences\r\n        .edit()\r\n        .putString(chatUid, keygen)\r\n        .apply()\r\n}\r\n\r\n@RequiresApi(Build.VERSION_CODES.M)\r\nfun getMetaOx(context: Context, chatUid: String): String? {\r\n\r\n    val keyGenParameterSpec = MasterKeys.AES256_GCM_SPEC\r\n    val masterKeyAlias = MasterKeys.getOrCreate(keyGenParameterSpec)\r\n    val sharedPreferences = EncryptedSharedPreferences.create(\r\n        \"meta_shared_preferences\",\r\n        masterKeyAlias,\r\n        context,\r\n        EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,\r\n        EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM\r\n    )\r\n\r\n    // reading a value\r\n    println(sharedPreferences.getString(chatUid, \"\"))\r\n    return sharedPreferences.getString(chatUid, \"\") // -> \"some_data\"\r\n}\r\n\r\nfun generateRandomIV(): String {\r\n    val ranGen = SecureRandom()\r\n    val aesKey = ByteArray(16)\r\n    ranGen.nextBytes(aesKey)\r\n    val result = StringBuffer()\r\n    for (b in aesKey) {\r\n        result.append(String.format(\"%02x\", b))\r\n    }\r\n    return if (16 > result.toString().length) {\r\n        result.toString()\r\n    } else {\r\n        result.toString().substring(0, 16)\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/singularity/ipcaplus/cryptography/metaData.kt b/app/src/main/java/com/singularity/ipcaplus/cryptography/metaData.kt
--- a/app/src/main/java/com/singularity/ipcaplus/cryptography/metaData.kt	(revision d7d49fadf70fadd33042282dce690a6bd606ece4)
+++ b/app/src/main/java/com/singularity/ipcaplus/cryptography/metaData.kt	(date 1642078199573)
@@ -24,12 +24,12 @@
 
 
 
-fun encryptMeta(strToEncrypt: String, secret_key: String): String? {
+fun encryptMeta(strToEncrypt: String, secret_key: String, initVector : String): String? {
     Security.addProvider(BouncyCastleProvider())
     hash(strToEncrypt)
     var keyBytes: ByteArray
     //val initVector = generateRandomIV()
-    val initVector = "7c5afb00aaecb1a1"
+    //val initVector = "7c5afb00aaecb1a1"
     val iv = IvParameterSpec(initVector.toByteArray(charset("UTF-8")))
     println("AVEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE $initVector")
 
@@ -72,10 +72,10 @@
     return null
 }
 
-fun decryptWithAESmeta(key: String, strToDecrypt: String?): String? {
+fun decryptWithAESmeta(key: String, strToDecrypt: String?, initVector : String): String? {
     Security.addProvider(BouncyCastleProvider())
     var keyBytes: ByteArray
-    val initVector = "7c5afb00aaecb1a1"
+    //val initVector = "7c5afb00aaecb1a1"
 
     try {
         val iv = IvParameterSpec(initVector.toByteArray(charset("UTF-8")))
@@ -137,7 +137,7 @@
     println(secretKey)
     return secretKey.toString()
 }
-
+/*
 fun metaBlock(message: String){
     //val secretKey: String = "662ede816988e58fb6d057d9d85605e0"
     val keygen = metaGenrateKey()
@@ -147,7 +147,7 @@
 
     val message_decripted = decryptWithAESmeta(keygen, meta)
     println(message_decripted)
-}
+}*/
 
 @RequiresApi(Build.VERSION_CODES.M)
 fun saveKeygenOx(context : Context, chatUid : String, keygen: String){
Index: app/src/main/java/com/singularity/ipcaplus/utils/Backend.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.singularity.ipcaplus.utils\r\n\r\nimport android.net.Uri\r\nimport com.google.firebase.Timestamp\r\nimport com.google.firebase.auth.ktx.auth\r\nimport com.google.firebase.firestore.Query\r\nimport com.google.firebase.firestore.ktx.firestore\r\nimport com.google.firebase.ktx.Firebase\r\nimport com.google.firebase.storage.FirebaseStorage\r\nimport com.google.firebase.storage.ktx.storage\r\nimport com.singularity.ipcaplus.R\r\nimport com.singularity.ipcaplus.models.*\r\nimport org.json.JSONArray\r\nimport java.io.File\r\n\r\nobject Backend {\r\n\r\n    val db = Firebase.firestore\r\n\r\n    /*\r\n       ------------------------------------------------ Events ------------------------------------------------\r\n    */\r\n\r\n    /*\r\n       This function returns all events during the month in the firebase to an list\r\n       @month = selected month\r\n       @callBack = return the list\r\n    */\r\n    fun getAllMonthEvents(month: String, callBack: (List<EventCalendar>)->Unit) {\r\n\r\n        val events = arrayListOf<EventCalendar>()\r\n\r\n        // Get all user chat ids\r\n        val chatIds = arrayListOf<String>()\r\n        getAllUserChatIds {\r\n            chatIds.addAll(it)\r\n\r\n            // Search in all chats\r\n            for (id in chatIds) {\r\n                db.collection(\"chat\")\r\n                    .document(id)\r\n                    .collection(\"event\")\r\n                    .addSnapshotListener { documents, _ ->\r\n\r\n                        documents?.let {\r\n\r\n                            for (document in documents) {\r\n                                val event = EventCalendar.fromHash(document)\r\n                                event.id = document.id\r\n\r\n                                val date = Utilis.getDate(event.datetime.seconds * 1000, \"yyyy-MM-dd'T'HH:mm:ss.SSS\")\r\n                                if (month == Utilis.getMonthById(Utilis.getMonth(date).toInt())) {\r\n                                    events.add(event)\r\n                                }\r\n                            }\r\n                            callBack(events)\r\n                        }\r\n                    }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    private fun getAllUserChatIds(callBack: (List<String>)->Unit) {\r\n\r\n        val chatIds = arrayListOf<String>()\r\n\r\n        // Get Group Chats Ids\r\n        db.collection(\"profile\").document(Firebase.auth.currentUser!!.uid).collection(\"chat\")\r\n            .addSnapshotListener { documents, _ ->\r\n                documents?.let {\r\n                    for (document in it) {\r\n                        chatIds.add(document.id)\r\n                    }\r\n\r\n                    callBack(chatIds)\r\n                }\r\n            }\r\n    }\r\n\r\n\r\n    /*\r\n       This function returns all events during the month in the firebase to an list\r\n       @month = selected month\r\n       @callBack = return the list\r\n    */\r\n    fun getAllChatMonthEvents(month: String, chat_id: String, callBack: (List<EventCalendar>)->Unit) {\r\n\r\n        val events = arrayListOf<EventCalendar>()\r\n\r\n        db.collection(\"chat\")\r\n            .document(chat_id)\r\n            .collection(\"event\")\r\n            .addSnapshotListener { documents, _ ->\r\n\r\n                documents?.let {\r\n\r\n                    for (document in documents) {\r\n                        val event = EventCalendar.fromHash(document)\r\n                        event.id = document.id\r\n\r\n                        val date = Utilis.getDate(\r\n                            event.datetime.seconds * 1000,\r\n                            \"yyyy-MM-dd'T'HH:mm:ss.SSS\"\r\n                        )\r\n                        if (month == Utilis.getMonthById(Utilis.getMonth(date).toInt())) {\r\n                            events.add(event)\r\n                        }\r\n                    }\r\n\r\n                    callBack(events)\r\n                }\r\n\r\n            }\r\n    }\r\n\r\n\r\n    /*\r\n       This function returns all events during the day in the firebase to an list\r\n       @day = selected day\r\n       @callBack = return the list\r\n    */\r\n    fun getAllChatMonthDayEvents(month: String, day: Int, chat_id: String, callBack: (List<EventCalendar>)->Unit) {\r\n\r\n        val events = arrayListOf<EventCalendar>()\r\n\r\n        db.collection(\"chat\")\r\n            .document(chat_id)\r\n            .collection(\"event\")\r\n            .addSnapshotListener { documents, _ ->\r\n\r\n                documents?.let {\r\n\r\n                    for (document in documents) {\r\n                        val event = EventCalendar.fromHash(document)\r\n                        event.id = document.id\r\n\r\n                        val date = Utilis.getDate(\r\n                            event.datetime.seconds * 1000,\r\n                            \"yyyy-MM-dd'T'HH:mm:ss.SSS\"\r\n                        )\r\n                        if (day == Utilis.getDay(date).toInt() && month == Utilis.getMonthById(\r\n                                Utilis.getMonth(date).toInt()\r\n                            )\r\n                        ) {\r\n                            events.add(event)\r\n                        }\r\n                    }\r\n\r\n                    callBack(events)\r\n                }\r\n\r\n            }\r\n    }\r\n\r\n\r\n    /*\r\n       This function returns all events during the day in the firebase to an list\r\n       @day = selected day\r\n       @callBack = return the list\r\n    */\r\n    fun getAllMonthDayEvents(month: String, day: Int, callBack: (List<EventCalendar>)->Unit) {\r\n\r\n        val events = arrayListOf<EventCalendar>()\r\n\r\n        // Get all user chat ids\r\n        val chatIds = arrayListOf<String>()\r\n        getAllUserChatIds {\r\n            chatIds.addAll(it)\r\n\r\n            // Search in all chats\r\n            for (id in chatIds) {\r\n                db.collection(\"chat\")\r\n                    .document(id)\r\n                    .collection(\"event\")\r\n                    .addSnapshotListener { documents, _ ->\r\n\r\n                        documents?.let {\r\n\r\n                            for (document in documents) {\r\n                                val event = EventCalendar.fromHash(document)\r\n                                event.id = document.id\r\n\r\n                                val date = Utilis.getDate(event.datetime.seconds * 1000, \"yyyy-MM-dd'T'HH:mm:ss.SSS\")\r\n                                if (day == Utilis.getDay(date).toInt() && month == Utilis.getMonthById(\r\n                                        Utilis.getMonth(date).toInt())\r\n                                ) {\r\n                                    events.add(event)\r\n                                }\r\n                            }\r\n\r\n                            callBack(events)\r\n                        }\r\n\r\n                    }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    fun deleteEvent(chatID: String, eventID: String) {\r\n\r\n        db.collection(\"chat\")\r\n            .document(chatID)\r\n            .collection(\"event\")\r\n            .document(eventID)\r\n            .delete()\r\n\r\n    }\r\n\r\n\r\n    /*\r\n       ------------------------------------------------ Schedule ------------------------------------------------\r\n    */\r\n\r\n    /*\r\n       This function returns all events in the firebase to an list\r\n       @callBack = return the list\r\n    */\r\n    fun getDayCourseSubjects(day: String, courseId: String, callBack: (List<Subject>)->Unit) {\r\n\r\n        val subjects = arrayListOf<Subject>()\r\n        val subjectsWithBreaks = arrayListOf<Subject>()\r\n\r\n        db.collection(\"course\").document(courseId).collection(\"subject\")\r\n            .addSnapshotListener { documents, _ ->\r\n                documents?.let {\r\n\r\n                    // Add every subject to the list\r\n                    for (document in documents) {\r\n                        val subject = Subject.fromHash(document)\r\n                        if (day == subject.day) {\r\n                            subjects.add(subject)\r\n                        }\r\n                    }\r\n\r\n                    // Order the subjects by time\r\n                    for (i in 0 until subjects.size) {\r\n                        for (j in 0 until subjects.size - 1) {\r\n\r\n                            if (Utilis.convertHoursStringToInt(subjects[j].start_time) > Utilis.convertHoursStringToInt(\r\n                                    subjects[j + 1].start_time\r\n                                )\r\n                            ) {\r\n                                val temp = subjects[j]\r\n                                subjects[j] = subjects[j + 1]\r\n                                subjects[j + 1] = temp\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // Add Break Times Between Classes\r\n                    for (i in 0 until subjects.size) {\r\n                        if (i % 2 == 0) {\r\n                            subjectsWithBreaks.add(subjects[i])\r\n                        }\r\n                        else {\r\n                            val diff = Utilis.convertHoursStringToInt(subjects[i].start_time) - Utilis.convertHoursStringToInt(\r\n                                subjects[i - 1].end_time\r\n                            )\r\n                            subjectsWithBreaks.add(Subject(\"breaktime\", diff.toString()))\r\n                            subjectsWithBreaks.add(subjects[i])\r\n                        }\r\n                    }\r\n\r\n                    callBack(subjectsWithBreaks)\r\n                }\r\n\r\n            }\r\n\r\n    }\r\n\r\n\r\n    /*\r\n       This function returns the user course by callback\r\n       @id = user uid\r\n    */\r\n    fun getUserCourses(uid: String, callBack:(String)->Unit) {\r\n\r\n        db.collection(\"profile\")\r\n            .document(uid)\r\n            .collection(\"course\")\r\n            .addSnapshotListener { documents, _ ->\r\n\r\n                documents?.let {\r\n\r\n                    var courseId = \"\"\r\n                    for (document in documents)\r\n                        courseId = document.id\r\n\r\n                    callBack(courseId)\r\n                }\r\n            }\r\n    }\r\n\r\n\r\n    /*\r\n       This function returns the user course by callback\r\n       @id = user uid\r\n    */\r\n    fun getUserCoursesIds(uid: String, courseTag: String, callBack:(List<String>)->Unit) {\r\n\r\n        val courseIds = arrayListOf<String>()\r\n\r\n        db.collection(\"course\")\r\n            .whereEqualTo(\"tag\", courseTag)\r\n            .get()\r\n            .addOnSuccessListener { documents ->\r\n\r\n                documents?.let {\r\n\r\n                    for (document in documents)\r\n                        courseIds.add(document.id)\r\n\r\n                    callBack(courseIds)\r\n                }\r\n\r\n            }\r\n\r\n    }\r\n\r\n\r\n    fun setUserCourses(userID: String, courseID: String) {\r\n\r\n        val profile = HashMap<String, Any>()\r\n        db.collection(\"profile\")\r\n            .document(userID)\r\n            .collection(\"course\")\r\n            .document(courseID)\r\n            .set(profile)\r\n    }\r\n\r\n\r\n    /*\r\n       ------------------------------------------------ Contacts ------------------------------------------------\r\n    */\r\n\r\n    /*\r\n       This function returns all contacts in the firebase to an list\r\n       @callBack = return the list\r\n    */\r\n    fun getAllContacts(callBack: (List<Contact>)->Unit) {\r\n\r\n        val contacts = arrayListOf<Contact>()\r\n\r\n        db.collection(\"contacts\")\r\n            .addSnapshotListener { documents, _ ->\r\n\r\n                documents?.let {\r\n\r\n                    for (document in documents) {\r\n                        val contact = Contact.fromHash(document)\r\n                        contacts.add(contact)\r\n                    }\r\n\r\n                    callBack(contacts)\r\n                }\r\n\r\n            }\r\n\r\n    }\r\n\r\n\r\n    /*\r\n       ------------------------------------------------ Profile ------------------------------------------------\r\n    */\r\n\r\n    fun getUserProfile(userId: String, callBack:(Profile)->Unit) {\r\n\r\n        var profile = Profile()\r\n\r\n        db.collection(\"profile\")\r\n            .addSnapshotListener { documents, _ ->\r\n\r\n                documents?.let {\r\n\r\n                    for (document in documents) {\r\n\r\n                        if (document.id == userId) {\r\n                            profile = Profile.fromHash(document)\r\n                            profile.id = document.id\r\n                        }\r\n                    }\r\n\r\n                    callBack(profile)\r\n                }\r\n            }\r\n    }\r\n\r\n    fun getAllUsers (callBack:(List<Profile>)->Unit) {\r\n        val profiles = arrayListOf<Profile>()\r\n\r\n        db.collection(\"profile\")\r\n            .addSnapshotListener { documents, _ ->\r\n                documents?.let {\r\n\r\n                    for (document in documents) {\r\n                        val profile = Profile.fromHash(document)\r\n                        profile.id = document.id\r\n                        profiles.add(profile)\r\n                    }\r\n                }\r\n\r\n                callBack(profiles)\r\n            }\r\n    }\r\n\r\n    fun getAllUsersExceptCurrent (callBack:(List<Profile>)->Unit) {\r\n        val profiles = arrayListOf<Profile>()\r\n\r\n        db.collection(\"profile\")\r\n            .addSnapshotListener { documents, _ ->\r\n                documents?.let {\r\n\r\n                    for (document in documents) {\r\n                        val profile = Profile.fromHash(document)\r\n\r\n                        if (Firebase.auth.currentUser!!.uid != document.id) {\r\n                            profile.id = document.id\r\n                            profiles.add(profile)\r\n                        }\r\n                    }\r\n                }\r\n\r\n                callBack(profiles)\r\n            }\r\n    }\r\n\r\n\r\n    fun getAllUsersExceptChatUsers (chatID: String, callBack:(List<Profile>)->Unit) {\r\n\r\n        val currentUserIds = arrayListOf<String>()\r\n        val profiles = arrayListOf<Profile>()\r\n\r\n        // Get current chat users ids\r\n        getChatUsers(chatID) {\r\n            for (user in it)\r\n                currentUserIds.add(user.id!!)\r\n\r\n            db.collection(\"profile\")\r\n                .addSnapshotListener { documents, _ ->\r\n                    documents?.let {\r\n\r\n                        for (document in documents) {\r\n                            val profile = Profile.fromHash(document)\r\n\r\n                            // Verify if user is not in the chat\r\n                            var found = false\r\n                            for (id in currentUserIds) {\r\n                                if (id == document.id)\r\n                                    found = true\r\n                            }\r\n\r\n                            if (!found) {\r\n                                profile.id = document.id\r\n                                profiles.add(profile)\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    callBack(profiles)\r\n                }\r\n        }\r\n    }\r\n\r\n\r\n    fun changeUserChatAdminStatus(chatId: String, userId: String, status: Boolean) {\r\n\r\n        db.collection(\"chat\")\r\n            .document(chatId)\r\n            .collection(\"user\")\r\n            .document(userId)\r\n            .update(\"admin\", status)\r\n\r\n    }\r\n\r\n\r\n    /*\r\n       ------------------------------------------------ Chats ------------------------------------------------\r\n    */\r\n\r\n\r\n    fun getChatUsers(chatID: String, callBack: (List<Profile>)->Unit) {\r\n\r\n        val userIds = arrayListOf<String>()\r\n        val adminIds = arrayListOf<String>()\r\n        val users = arrayListOf<Profile>()\r\n\r\n        // Get the ids of the users in the chat\r\n        db.collection(\"chat\")\r\n            .document(chatID)\r\n            .collection(\"user\")\r\n            .addSnapshotListener { documents, _ ->\r\n                documents?.let {\r\n                    for (document in documents) {\r\n                        userIds.add(document.id)\r\n\r\n                        if (document[\"admin\"] != true)\r\n                            adminIds.add(document.id)\r\n\r\n                    }\r\n                }\r\n\r\n                // Find the data for each id\r\n                db.collection(\"profile\")\r\n                    .addSnapshotListener { documents2, _ ->\r\n                        documents2?.let {\r\n                            for (document in documents2) {\r\n                                for (id in userIds) {\r\n                                    if (document.id == id) {\r\n                                        val profile = Profile.fromHash(document)\r\n                                        profile.id = document.id\r\n                                        users.add(profile)\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // Get Admins\r\n                        for (u in users) {\r\n                            for (a in adminIds) {\r\n                                if (u.id == a) {\r\n                                    u.isAdmin = true\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        callBack(users)\r\n                    }\r\n\r\n            }\r\n\r\n    }\r\n\r\n\r\n    fun getChatUsersUids(chatID: String, callBack: (List<String>) -> Unit){\r\n        var userIds = arrayListOf<String>()\r\n\r\n        // Get the ids of the users in the chat\r\n        db.collection(\"chat\")\r\n            .document(chatID)\r\n            .collection(\"user\")\r\n            .addSnapshotListener { documents, _ ->\r\n                documents?.let {\r\n                    for (document in documents) {\r\n                        userIds.add(document.id)\r\n                    }\r\n                }\r\n\r\n                callBack(userIds)\r\n            }\r\n    }\r\n\r\n\r\n    fun changeChatName(chatID: String, newName: String) {\r\n\r\n        db.collection(\"chat\")\r\n            .document(chatID)\r\n            .update(\"name\", newName)\r\n    }\r\n\r\n\r\n    /*\r\n       This function returns last chat message by chat id\r\n       @callBack = return the message\r\n    */\r\n    fun getLastMessageByChatID(chatID: String, callBack: (Message?)->Unit) {\r\n\r\n        var message : Message? = null\r\n\r\n        db.collection(\"chat\").document(\"${chatID}\").collection(\"message\")\r\n            .orderBy(\"time\", Query.Direction.DESCENDING).limit(1)\r\n            .addSnapshotListener { documents, _ ->\r\n                documents?.let {\r\n                    for (document in documents) {\r\n                        message = Message.fromHash(document)\r\n                        }\r\n                    }\r\n\r\n                    callBack(message)\r\n                }\r\n\r\n    }\r\n\r\n\r\n    fun getChatAdminIds(chatID: String, callBack: (List<String>)->Unit) {\r\n\r\n        val adminIds = arrayListOf<String>()\r\n\r\n        // Get Admins\r\n        db.collection(\"chat\")\r\n            .document(chatID)\r\n            .collection(\"user\")\r\n            .addSnapshotListener { documents, _ ->\r\n                documents?.let {\r\n                    for (document in documents) {\r\n\r\n                        if (document[\"admin\"] == true)\r\n                            adminIds.add(document.id)\r\n\r\n                    }\r\n\r\n                    callBack(adminIds)\r\n                }\r\n            }\r\n\r\n    }\r\n\r\n\r\n    fun removeUserFromChat(chatId: String, userId: String) {\r\n\r\n        // remover user from chat user list\r\n        db.collection(\"chat\")\r\n            .document(chatId)\r\n            .collection(\"user\")\r\n            .document(userId)\r\n            .delete()\r\n\r\n        // remove chat from user chat list\r\n        db.collection(\"profile\")\r\n            .document(userId)\r\n            .collection(\"chat\")\r\n            .document(chatId)\r\n            .delete()\r\n    }\r\n\r\n\r\n    fun addUsersIntoChat(chat: Chat, chatId: String, usersId: ArrayList<String>, callBack: ()->Unit) {\r\n\r\n        for (userId in usersId) {\r\n\r\n            // Create chat in user profile\r\n            db.collection(\"profile\")\r\n                .document(userId)\r\n                .collection(\"chat\")\r\n                .document(chatId)\r\n                .set(chat)\r\n                .addOnCompleteListener {\r\n\r\n                    val profile = HashMap<String, Any>()\r\n                    db.collection(\"chat\")\r\n                        .document(chatId)\r\n                        .collection(\"user\")\r\n                        .document(userId)\r\n                        .set(profile)\r\n                        .addOnCompleteListener {\r\n                            callBack()\r\n                        }\r\n\r\n                }\r\n\r\n        }\r\n    }\r\n\r\n\r\n    fun deleteChat(chatId: String, callback: ()->Unit) {\r\n\r\n        val userIds = arrayListOf<String>()\r\n\r\n        // get all chat members ids\r\n        db.collection(\"chat\")\r\n            .document(chatId)\r\n            .collection(\"user\")\r\n            .addSnapshotListener { documents, _ ->\r\n\r\n                documents?.let {\r\n                    for (document in documents) {\r\n                        userIds.add(document.id)\r\n                    }\r\n\r\n                    // <------------------------------------------------------- Missing here\r\n\r\n                    // delete chat\r\n                    /*\r\n                    db.collection(\"chat\")\r\n                        .document(chatId)\r\n                        .delete()\r\n*/\r\n\r\n                    // delete chat references in members\r\n                    for (i in 0 until userIds.size) {\r\n\r\n                        db.collection(\"profile\")\r\n                            .document(userIds[i])\r\n                            .collection(\"chat\")\r\n                            .document(chatId)\r\n                            .delete()\r\n                            .addOnCompleteListener {\r\n                                // If its the last callback refresh the activity\r\n                                if (i == userIds.size - 1)\r\n                                    callback()\r\n                            }\r\n\r\n                    }\r\n            }\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    fun getAllDirectChatIdsByUser(userId: String, callBack: (List<String?>) -> Unit){\r\n\r\n        var chatIds = arrayListOf<String?>()\r\n\r\n        // Get all profile chat ids\r\n        db.collection(\"profile\")\r\n            .document(userId)\r\n            .collection(\"chat\")\r\n            .whereEqualTo(\"type\", \"chat\")\r\n            .get()\r\n            .addOnSuccessListener { documents ->\r\n                for (document in documents) {\r\n                    chatIds.add(document.id)\r\n                }\r\n\r\n                println(\"DEntroooo\" + chatIds)\r\n                callBack(chatIds)\r\n            }\r\n\r\n    }\r\n\r\n    fun getDirectChatById(chatIds: List<String?>, userId: String, callBack: (String?)-> Unit) {\r\n\r\n        var chatId : String? = null\r\n\r\n        for (id in chatIds) {\r\n            db.collection(\"chat\")\r\n                .document(id!!)\r\n                .collection(\"user\")\r\n                .get()\r\n                .addOnSuccessListener { documents ->\r\n                    for(document in documents) {\r\n                        if(document.id == userId){\r\n                            chatId = id\r\n                        }\r\n                    }\r\n\r\n                    println(\"ACABOU2---------------------------------------\")\r\n                    callBack(chatId)\r\n                }\r\n        }\r\n\r\n    }\r\n\r\n\r\n    /*\r\n       ------------------------------------------------ Register Manipulation ------------------------------------------------\r\n    */\r\n\r\n    fun getIpcaData(email: String, callBack: (Profile?)->Unit) {\r\n\r\n        var profile : Profile? = null\r\n\r\n        db.collection(\"ipca_data\")\r\n            .whereEqualTo(\"email\", email)\r\n            .get()\r\n            .addOnSuccessListener { documents ->\r\n\r\n                for (document in documents) {\r\n                    profile = Profile.fromHash(document)\r\n                }\r\n\r\n                callBack(profile)\r\n\r\n            }\r\n\r\n    }\r\n\r\n\r\n    /*\r\n       ------------------------------------------------ Files ------------------------------------------------\r\n    */\r\n\r\n    fun getAllChatFolderFiles(path: String, callBack: (List<FirebaseFile>) -> Unit) {\r\n\r\n        val files = arrayListOf<FirebaseFile>()\r\n        val listRef = Firebase.storage.reference.child(path)\r\n\r\n        // Find all the prefixes and items.\r\n        listRef.listAll().addOnSuccessListener {\r\n\r\n            for (i in it.prefixes) {\r\n                files.add(FirebaseFile(i.name, R.drawable.ic_folder))\r\n            }\r\n\r\n            for (i in it.items) {\r\n                val icon = Utilis.getFileIcon(i.name)\r\n                if (icon != -1) {\r\n                    val file = FirebaseFile(i.name, icon)\r\n                    files.add(file)\r\n                }\r\n            }\r\n\r\n            callBack(files)\r\n        }\r\n\r\n    }\r\n\r\n    /*\r\n      ------------------------------------------------ Files ------------------------------------------------\r\n   */\r\n\r\n\r\n    fun deleteAllFilesInsideFolder(filePath: String, callback: ()->Unit) {\r\n\r\n        val storage = Firebase.storage\r\n        val listRef = storage.reference.child(filePath)\r\n\r\n        listRef.listAll()\r\n            .addOnSuccessListener {\r\n\r\n                it.items.forEach { item ->\r\n                    item.delete()\r\n                        .addOnCompleteListener {\r\n                            callback()\r\n                        }\r\n                }\r\n\r\n            }\r\n    }\r\n\r\n\r\n    fun getFileUrl(filePath: String, callback: (Uri)->Unit) {\r\n\r\n        val storageRef = FirebaseStorage.getInstance().reference.child(filePath)\r\n\r\n        storageRef.downloadUrl.addOnCompleteListener {\r\n            callback(it.result!!)\r\n        }\r\n\r\n    }\r\n\r\n\r\n    fun postTokenAddress(tokenAdress: String, uid: String){\r\n        println(tokenAdress)\r\n        println(uid)\r\n        var token = HashMap<String, String>()\r\n        db.collection(\"profile\")\r\n            .document(uid)\r\n            .collection(\"tokens\")\r\n            .document(tokenAdress)\r\n            .set(token)\r\n    }\r\n\r\n    fun getAllTokens(uid: String, callBack: (List<String>) -> Unit){\r\n        val tokens = arrayListOf<String>()\r\n\r\n        db.collection(\"profile\").document(uid).collection(\"tokens\")\r\n            .addSnapshotListener { documents, _ ->\r\n                documents?.let {\r\n                    for (document in documents) {\r\n                            tokens.add(document.id)\r\n                    }\r\n\r\n                    callBack(tokens)\r\n                }\r\n            }\r\n\r\n    }\r\n\r\n    fun createJsonArrayString(array: List<String>): JSONArray {\r\n        return JSONArray(array)\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/singularity/ipcaplus/utils/Backend.kt b/app/src/main/java/com/singularity/ipcaplus/utils/Backend.kt
--- a/app/src/main/java/com/singularity/ipcaplus/utils/Backend.kt	(revision d7d49fadf70fadd33042282dce690a6bd606ece4)
+++ b/app/src/main/java/com/singularity/ipcaplus/utils/Backend.kt	(date 1642079549056)
@@ -866,4 +866,22 @@
     fun createJsonArrayString(array: List<String>): JSONArray {
         return JSONArray(array)
     }
+
+    fun getIv(chat_id: String, callBack: (String?)->Unit) {
+
+        var iv : String? = null
+
+        db.collection("chat")
+            .get()
+            .addOnSuccessListener { documents ->
+                for(document in documents) {
+                    if (document.id == chat_id) {
+                        val chat = Chat.fromHash(document)
+                        iv = chat.iv.toString()
+                    }
+                }
+                callBack(iv)
+            }
+    }
+
 }
\ No newline at end of file
